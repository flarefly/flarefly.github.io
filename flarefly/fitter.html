<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>flarefly.fitter API documentation</title>
<meta name="description" content="Module containing the class used to perform mass fits" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>flarefly.fitter</code></h1>
</header>
<section id="section-intro">
<p>Module containing the class used to perform mass fits</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module containing the class used to perform mass fits
&#34;&#34;&#34;

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from matplotlib.offsetbox import AnchoredText

import zfit
import uproot
from hist import Hist
import mplhep
from particle import Particle
from flarefly.utils import Logger
import flarefly.custom_pdfs as cpdf


# pylint: disable=too-many-instance-attributes, too-many-lines, too-many-public-methods
class F2MassFitter:
    &#34;&#34;&#34;
    Class used to perform mass fits with the zfit library
    https://github.com/zfit/zfit
    &#34;&#34;&#34;

    # pylint: disable=too-many-statements
    def __init__(self, data_handler, name_signal_pdf, name_background_pdf, **kwargs):
        &#34;&#34;&#34;
        Initialize the F2MassFitter class
        Parameters
        -------------------------------------------------
        data_handler: flarefly.DataHandler
            The data handler containing the data to fit

        name_signal_pdf: list
            The list of names for the signal pdfs. The possible options are:

            - &#39;gaussian&#39;

            - &#39;doublegaus&#39;

            - &#39;crystalball&#39;

            - &#39;doublecb&#39;

            - &#39;cauchy&#39;

            - &#39;voigtian&#39;

            - &#39;kde_exact&#39; (requires to set the datasample and options)

            - &#39;kde_grid&#39; (requires to set the datasample and options)

            - &#39;kde_fft&#39; (requires to set the datasample and options)

            - &#39;kde_isj&#39; (requires to set the datasample and options)

            - &#39;hist&#39; (only for binned fits, requires to set the datasample)

        name_background_pdf: list
            The list of names of the background pdfs. The possible options are:

            - &#39;nobkg&#39;

            - &#39;expo&#39;

            - &#39;powlaw&#39;

            - &#39;expopow&#39;

            - &#39;chebpolN&#39; (N is the order of the polynomial)

            - &#39;kde_exact&#39; (requires to set the datasample and options)

            - &#39;kde_grid&#39; (requires to set the datasample and options)

            - &#39;kde_fft&#39; (requires to set the datasample and options)

            - &#39;kde_isj&#39; (requires to set the datasample and options)

            - &#39;hist&#39; (only for binned fits, requires to set the datasample)

        **kwargs: dict
            Additional optional arguments:

            - name_refl_pdf: list
                The list of names of the signal pdfs. It must have the same length as the signal list.
                The possible options are:

                - &#39;kde_exact&#39; (requires to set the datasample and options)

                - &#39;kde_grid&#39; (requires to set the datasample and options)

                - &#39;kde_fft&#39; (requires to set the datasample and options)

                - &#39;kde_isj&#39; (requires to set the datasample and options)

                - &#39;hist&#39; (only for binned fits, requires to set the datasample)

            - name: str
                Optional name for the fitter,
                needed in case of multiple fitters defined in the same script

            - chi2_loss: bool
                chi2 minimization if True, nll minmization else
                Default value to False
        &#34;&#34;&#34;

        self._data_handler_ = data_handler
        self._name_signal_pdf_ = name_signal_pdf
        self._name_background_pdf_ = name_background_pdf
        self._signal_pdf_ = [None for _ in enumerate(name_signal_pdf)]
        self._hist_signal_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_signal_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_signal_option_ = [None for _ in enumerate(name_signal_pdf)]
        if self._name_background_pdf_[0] == &#39;nobkg&#39;:
            self._background_pdf_ = []
            self._hist_bkg_sample_ = []
            self._kde_bkg_sample_ = []
            self._kde_bkg_option_ = []
        else:
            self._background_pdf_ = [None for _ in enumerate(name_background_pdf)]
            self._hist_bkg_sample_ = [None for _ in enumerate(name_background_pdf)]
            self._kde_bkg_sample_ = [None for _ in enumerate(name_background_pdf)]
            self._kde_bkg_option_ = [None for _ in enumerate(name_background_pdf)]
        self._name_refl_pdf_ = kwargs.get(&#39;name_refl_pdf&#39;, [None for _ in enumerate(name_signal_pdf)])
        if len(self._name_refl_pdf_) != len(self._name_signal_pdf_):
            Logger(&#39;List of pdfs for signals and reflections different! Exit&#39;, &#39;FATAL&#39;)
        self._refl_pdf_ = [None for _ in enumerate(name_signal_pdf)]
        self._hist_refl_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_refl_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_refl_option_ = [None for _ in enumerate(name_signal_pdf)]
        self._refl_over_sgn_ = [0. for _ in enumerate(name_signal_pdf)]
        self._total_pdf_ = None
        self._total_pdf_binned_ = None
        self._fit_result_ = None
        self._init_sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._init_bkg_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._limits_sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._limits_bkg_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._fix_sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._fix_bkg_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._bkg_pars_ = [{} for _ in enumerate(name_background_pdf)]
        if self._name_background_pdf_[0] == &#39;nobkg&#39;:
            self._fracs_ = [None for _ in range(2 * len(name_signal_pdf) - 1)]
        else:
            self._fracs_ = [None for _ in range(2 * len(name_signal_pdf) + len(name_background_pdf) - 1)]
        self._rawyield_ = [0. for _ in enumerate(name_signal_pdf)]
        self._rawyield_err_ = [0. for _ in enumerate(name_signal_pdf)]
        self._minimizer_ = zfit.minimize.Minuit(verbosity=7)
        self._name_ = kwargs.get(&#39;name&#39;, &#39;&#39;)
        self._ndf_ = None
        self._chi2_loss_ = kwargs.get(&#39;chi2_loss&#39;, False)
        self._base_sgn_cmap_ = plt.cm.get_cmap(&#39;viridis&#39;, len(self._signal_pdf_) * 4)
        self._sgn_cmap_ = ListedColormap(self._base_sgn_cmap_(np.linspace(0.4, 0.65, len(self._signal_pdf_))))
        self._base_bkg_cmap_ = plt.cm.get_cmap(&#39;gist_heat&#39;, len(self._background_pdf_) * 2)
        self._bkg_cmap_ = ListedColormap(self._base_bkg_cmap_(np.linspace(0.3, 0.8, len(self._background_pdf_))))
        self._base_refl_cmap_ = plt.cm.get_cmap(&#39;summer&#39;, len(self._refl_pdf_) * 2)
        self._refl_cmap_ = ListedColormap(self._base_refl_cmap_(np.linspace(0., 0.6, len(self._refl_pdf_))))

        zfit.settings.advanced_warnings.all = False
        zfit.settings.changed_warnings.all = False

    # pylint: disable=too-many-branches, too-many-statements
    def __build_signal_pdfs(self, obs):
        &#34;&#34;&#34;
        Helper function to compose the signal pdfs
        &#34;&#34;&#34;

        for ipdf, pdf_name in enumerate(self._name_signal_pdf_):
            if pdf_name == &#39;gaussian&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.Gauss(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;doublegaus&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma1&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma2&#39;, 0.100)
                self._init_sgn_pars_[ipdf].setdefault(&#39;frac1&#39;, 0.9)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma1&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma2&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;frac1&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma1&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma2&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;frac1&#39;, [0., 1.])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma1_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma1_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma1&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma1&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma1&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma1&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma2_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma2_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma2&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma2&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma2&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma1&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_frac1_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_frac1_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;frac1&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;frac1&#39;][0], self._limits_sgn_pars_[ipdf][&#39;frac1&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;frac1&#39;])
                self._signal_pdf_[ipdf] = cpdf.DoubleGauss(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma1=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma1_signal{ipdf}&#39;],
                    sigma2=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma2_signal{ipdf}&#39;],
                    frac1=self._sgn_pars_[ipdf][f&#39;{self._name_}_frac1_signal{ipdf}&#39;],
                )
            elif pdf_name == &#39;crystalball&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;alpha&#39;, 0.5)
                self._init_sgn_pars_[ipdf].setdefault(&#39;n&#39;, 1.)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;alpha&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;n&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;alpha&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;n&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_alpha_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_alpha_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;alpha&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;alpha&#39;][0], self._limits_sgn_pars_[ipdf][&#39;alpha&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;alpha&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_n_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_n_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;n&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;n&#39;][0], self._limits_sgn_pars_[ipdf][&#39;n&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;n&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.CrystalBall(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;],
                    alpha=self._sgn_pars_[ipdf][f&#39;{self._name_}_alpha_signal{ipdf}&#39;],
                    n=self._sgn_pars_[ipdf][f&#39;{self._name_}_n_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;doublecb&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;alphal&#39;, 0.5)
                self._init_sgn_pars_[ipdf].setdefault(&#39;nl&#39;, 1.)
                self._init_sgn_pars_[ipdf].setdefault(&#39;alphar&#39;, 0.5)
                self._init_sgn_pars_[ipdf].setdefault(&#39;nr&#39;, 1.)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;alphal&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;nl&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;alphar&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;nr&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;alphal&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;nl&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;alphar&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;nr&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_alphal_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_alphal_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;alphal&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;alphal&#39;][0], self._limits_sgn_pars_[ipdf][&#39;alphal&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;alphal&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_nl_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_nl_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;nl&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;nl&#39;][0], self._limits_sgn_pars_[ipdf][&#39;nl&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;nl&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_alphar_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_alphar_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;alphar&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;alphar&#39;][0], self._limits_sgn_pars_[ipdf][&#39;alphar&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;alphar&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_nr_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_nr_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;nr&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;nr&#39;][0], self._limits_sgn_pars_[ipdf][&#39;nr&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;nr&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.DoubleCB(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;],
                    alphal=self._sgn_pars_[ipdf][f&#39;{self._name_}_alphal_signal{ipdf}&#39;],
                    nl=self._sgn_pars_[ipdf][f&#39;{self._name_}_nl_signal{ipdf}&#39;],
                    alphar=self._sgn_pars_[ipdf][f&#39;{self._name_}_alphar_signal{ipdf}&#39;],
                    nr=self._sgn_pars_[ipdf][f&#39;{self._name_}_nr_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;cauchy&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;m&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, 0.010)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;m&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;m&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_m_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_m_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;m&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;m&#39;][0], self._limits_sgn_pars_[ipdf][&#39;m&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;m&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_gamma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;gamma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;gamma&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.Cauchy(
                    obs=obs,
                    m=self._sgn_pars_[ipdf][f&#39;{self._name_}_m_signal{ipdf}&#39;],
                    gamma=self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;voigtian&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_gamma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;gamma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;gamma&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._signal_pdf_[ipdf] = cpdf.Voigtian(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;],
                    gamma=self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;]
                )
            elif &#39;kde&#39; in pdf_name:
                if self._kde_signal_sample_[ipdf]:
                    if pdf_name == &#39;kde_exact&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimExact(self._kde_signal_sample_[ipdf].get_data(),
                                                                        obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                        name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                        **self._kde_signal_option_[ipdf])
                    elif pdf_name == &#39;kde_grid&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimGrid(self._kde_signal_sample_[ipdf].get_data(),
                                                                       obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                       name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                       **self._kde_signal_option_[ipdf])
                    elif pdf_name == &#39;kde_fft&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimFFT(self._kde_signal_sample_[ipdf].get_data(),
                                                                      obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                      name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                      **self._kde_signal_option_[ipdf])
                    elif pdf_name == &#39;kde_isj&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimISJ(self._kde_signal_sample_[ipdf].get_data(),
                                                                      obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                      name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                      **self._kde_signal_option_[ipdf])
                else:
                    Logger(f&#39;Missing datasample for Kernel Density Estimation of signal {ipdf}!&#39;, &#39;FATAL&#39;)
            elif pdf_name == &#39;hist&#39;:
                if self._hist_signal_sample_[ipdf]:
                    self._signal_pdf_[ipdf] = zfit.pdf.SplinePDF(
                        zfit.pdf.HistogramPDF(self._hist_signal_sample_[ipdf].get_binned_data(),
                                              name=f&#39;{self._name_}_hist_signal{ipdf}&#39;),
                        order=3,
                        obs=obs
                    )
                else:
                    Logger(f&#39;Missing datasample for histogram template of signal {ipdf}!&#39;, &#39;FATAL&#39;)
            else:
                Logger(f&#39;Signal pdf {pdf_name} not supported&#39;, &#39;FATAL&#39;)

    def __build_background_pdfs(self, obs):
        &#34;&#34;&#34;
        Helper function to compose the background pdfs
        &#34;&#34;&#34;

        for ipdf, pdf_name in enumerate(self._name_background_pdf_):
            if pdf_name == &#39;nobkg&#39;:
                Logger(&#39;Performing fit with no bkg pdf&#39;, &#39;WARNING&#39;)
                break
            if pdf_name == &#39;expo&#39;:
                self._init_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, 0.1)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, [-1.e6, 1.e6])
                self._fix_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, False)
                self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_lam_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;lam&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;lam&#39;][0], self._limits_bkg_pars_[ipdf][&#39;lam&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;lam&#39;])
                self._background_pdf_[ipdf] = zfit.pdf.Exponential(
                    obs=obs,
                    lam=self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;]
                )
            elif &#39;chebpol&#39; in pdf_name:
                pol_degree = int(pdf_name.split(&#39;chebpol&#39;)[1])
                for deg in range(pol_degree + 1):
                    self._init_bkg_pars_[ipdf].setdefault(f&#39;c{deg}&#39;, 0.1)
                    self._limits_bkg_pars_[ipdf].setdefault(f&#39;c{deg}&#39;, [-1.e6, 1.e6])
                    self._fix_bkg_pars_[ipdf].setdefault(f&#39;c{deg}&#39;, False)
                    self._bkg_pars_[ipdf][f&#39;{self._name_}_c{deg}_bkg{ipdf}&#39;] = zfit.Parameter(
                        f&#39;{self._name_}_c{deg}_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][f&#39;c{deg}&#39;],
                        self._limits_bkg_pars_[ipdf][f&#39;c{deg}&#39;][0], self._limits_bkg_pars_[ipdf][f&#39;c{deg}&#39;][1],
                        floating=not self._fix_bkg_pars_[ipdf][f&#39;c{deg}&#39;])
                coeff0 = self._bkg_pars_[ipdf][f&#39;{self._name_}_c0_bkg{ipdf}&#39;]
                bkg_coeffs = [self._bkg_pars_[ipdf][f&#39;{self._name_}_c{deg}_bkg{ipdf}&#39;]
                              for deg in range(1, pol_degree + 1)]
                self._background_pdf_[ipdf] = zfit.pdf.Chebyshev(obs=obs, coeffs=bkg_coeffs, coeff0=coeff0)
            elif &#39;powlaw&#39; in pdf_name:
                self._init_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, Particle.from_pdgid(211).mass*1e-3) # pion mass as default
                self._init_bkg_pars_[ipdf].setdefault(&#39;power&#39;, 1.)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, [0., 1.e6])
                self._limits_bkg_pars_[ipdf].setdefault(&#39;power&#39;, [-1.e6, 1.e6])
                self._fix_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, True)
                self._fix_bkg_pars_[ipdf].setdefault(&#39;power&#39;, False)
                if self._data_handler_.get_limits()[0] &lt; self._init_bkg_pars_[ipdf][&#34;mass&#34;]:
                    Logger(&#39;The mass parameter in powlaw cannot be smaller than the lower fit limit, please fix it.&#39;,
                           &#39;FATAL&#39;)
                self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mass_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;mass&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;mass&#39;][0], self._limits_bkg_pars_[ipdf][&#39;mass&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;mass&#39;])
                self._bkg_pars_[ipdf][f&#39;{self._name_}_power_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_power_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;power&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;power&#39;][0], self._limits_bkg_pars_[ipdf][&#39;power&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;power&#39;])
                self._background_pdf_[ipdf] = cpdf.Pow(
                    obs=obs,
                    mass=self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;],
                    power=self._bkg_pars_[ipdf][f&#39;{self._name_}_power_bkg{ipdf}&#39;]
                )
            elif &#39;expopow&#39; in pdf_name:
                self._init_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, Particle.from_pdgid(211).mass*1e-3) # pion mass as default
                self._init_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, 0.1)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, [0., 1.e6])
                self._limits_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, [-1.e6, 1.e6])
                self._fix_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, True)
                self._fix_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, False)
                if self._data_handler_.get_limits()[0] &lt; self._init_bkg_pars_[ipdf][&#34;mass&#34;]:
                    Logger(&#39;The mass parameter in expopow cannot be smaller than the lower fit limit, please fix it.&#39;,
                           &#39;FATAL&#39;)
                self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mass_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;mass&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;mass&#39;][0], self._limits_bkg_pars_[ipdf][&#39;mass&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;mass&#39;])
                self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_lam_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;lam&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;lam&#39;][0], self._limits_bkg_pars_[ipdf][&#39;lam&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;lam&#39;])
                self._background_pdf_[ipdf] = cpdf.ExpoPow(
                    obs=obs,
                    mass=self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;],
                    lam=self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;]
                )
            elif &#39;kde&#39; in pdf_name:
                if self._kde_bkg_sample_[ipdf]:
                    if pdf_name == &#39;kde_exact&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimExact(self._kde_bkg_sample_[ipdf].get_data(),
                                                                            obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                            name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                            **self._kde_bkg_option_[ipdf])
                    elif pdf_name == &#39;kde_grid&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimGrid(self._kde_bkg_sample_[ipdf].get_data(),
                                                                           obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                           name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                           **self._kde_bkg_option_[ipdf])
                    elif pdf_name == &#39;kde_fft&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimFFT(self._kde_bkg_sample_[ipdf].get_data(),
                                                                          obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                          name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                          **self._kde_bkg_option_[ipdf])
                    elif pdf_name == &#39;kde_isj&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimISJ(self._kde_bkg_sample_[ipdf].get_data(),
                                                                          obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                          name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                          **self._kde_bkg_option_[ipdf])

                else:
                    Logger(f&#39;Missing datasample for Kernel Density Estimation of background {ipdf}!&#39;, &#39;FATAL&#39;)
            elif pdf_name == &#39;hist&#39;:
                if self._hist_bkg_sample_[ipdf]:
                    self._background_pdf_[ipdf] = zfit.pdf.SplinePDF(
                        zfit.pdf.HistogramPDF(self._hist_bkg_sample_[ipdf].get_binned_data(),
                                              name=f&#39;{self._name_}_hist_background{ipdf}&#39;),
                        order=3,
                        obs=obs
                    )
                else:
                    Logger(f&#39;Missing datasample for histogram template of background {ipdf}!&#39;, &#39;FATAL&#39;)
            else:
                Logger(f&#39;Background pdf {pdf_name} not supported&#39;, &#39;FATAL&#39;)

    # pylint: disable=too-many-branches, too-many-statements
    def __build_reflection_pdfs(self, obs):
        &#34;&#34;&#34;
        Helper function to compose the reflection pdfs
        &#34;&#34;&#34;

        for ipdf, pdf_name in enumerate(self._name_refl_pdf_):
            if pdf_name is None: # by default we put a dummy pdf
                low = zfit.Parameter(f&#39;{self._name_}_low_refl{ipdf}&#39;,
                                     self._data_handler_.get_limits()[0],
                                     self._data_handler_.get_limits()[0]*0.99,
                                     self._data_handler_.get_limits()[0]*1.01,
                                     floating=False)
                high = zfit.Parameter(f&#39;{self._name_}_high_refl{ipdf}&#39;,
                                      self._data_handler_.get_limits()[1],
                                      self._data_handler_.get_limits()[1]*0.99,
                                      self._data_handler_.get_limits()[1]*1.01,
                                      floating=False)
                self._refl_pdf_[ipdf] = zfit.pdf.Uniform(obs=obs, low=low, high=high)
            elif &#39;kde&#39; in pdf_name:
                if self._kde_refl_sample_[ipdf]:
                    if pdf_name == &#39;kde_exact&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimExact(self._kde_refl_sample_[ipdf].get_data(),
                                                                      obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                      name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                      **self._kde_refl_option_[ipdf])
                    elif pdf_name == &#39;kde_grid&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimGrid(self._kde_refl_sample_[ipdf].get_data(),
                                                                     obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                     name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                     **self._kde_refl_option_[ipdf])
                    elif pdf_name == &#39;kde_fft&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimFFT(self._kde_refl_sample_[ipdf].get_data(),
                                                                    obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                    name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                    **self._kde_refl_option_[ipdf])
                    elif pdf_name == &#39;kde_isj&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimISJ(self._kde_refl_sample_[ipdf].get_data(),
                                                                    obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                    name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                    **self._kde_refl_option_[ipdf])
                else:
                    Logger(f&#39;Missing datasample for Kernel Density Estimation of reflection {ipdf}!&#39;, &#39;FATAL&#39;)
            elif pdf_name == &#39;hist&#39;:
                if self._hist_refl_sample_[ipdf]:
                    self._refl_pdf_[ipdf] = zfit.pdf.SplinePDF(
                        zfit.pdf.HistogramPDF(self._hist_refl_sample_[ipdf].get_binned_data(),
                                              name=f&#39;{self._name_}_hist_refl{ipdf}&#39;),
                        order=3,
                        obs=obs
                    )
                else:
                    Logger(f&#39;Missing datasample for histogram template of reflections {ipdf}!&#39;, &#39;FATAL&#39;)
            else:
                Logger(f&#39;Reflection pdf {pdf_name} not supported&#39;, &#39;FATAL&#39;)

    def __build_total_pdf(self):
        &#34;&#34;&#34;
        Helper function to compose the total pdf
        &#34;&#34;&#34;

        obs = self._data_handler_.get_obs()

        # order of the pdfs is signal, background

        self.__build_signal_pdfs(obs)
        self.__build_background_pdfs(obs)
        self.__build_reflection_pdfs(obs)

        if len(self._signal_pdf_) + len(self._background_pdf_) == 1:
            self._total_pdf_ = self._signal_pdf_[0]
            return

        for ipdf, _ in enumerate(self._signal_pdf_):
            self._init_sgn_pars_[ipdf].setdefault(&#39;frac&#39;, 0.1)
            self._fix_sgn_pars_[ipdf].setdefault(&#39;frac&#39;, False)
            self._limits_sgn_pars_[ipdf].setdefault(&#39;frac&#39;, [0, 1.])
            if len(self._background_pdf_) == 0 and ipdf == len(self._signal_pdf_) - 1:
                continue
            self._fracs_[ipdf] = zfit.Parameter(f&#39;{self._name_}_frac_signal{ipdf}&#39;,
                                                self._init_sgn_pars_[ipdf][&#39;frac&#39;],
                                                self._limits_sgn_pars_[ipdf][&#39;frac&#39;][0],
                                                self._limits_sgn_pars_[ipdf][&#39;frac&#39;][1],
                                                floating=not self._fix_sgn_pars_[ipdf][&#39;frac&#39;])

            # normalisation of reflection fixed to the one of the signal
            def func_mult(params):
                return params[&#39;ros&#39;] * params[&#39;s&#39;]
            self._fracs_[ipdf + len(self._signal_pdf_)] = zfit.ComposedParameter(
                f&#39;{self._name_}_frac_refl{ipdf}&#39;,
                func_mult, params={&#39;ros&#39; : self._refl_over_sgn_[ipdf],
                                   &#39;s&#39; : self._fracs_[ipdf]}
            )

        if len(self._background_pdf_) &gt; 1:
            for ipdf, _ in enumerate(self._background_pdf_):
                self._init_bkg_pars_[ipdf].setdefault(&#39;frac&#39;, 0.1)
                self._fix_bkg_pars_[ipdf].setdefault(&#39;frac&#39;, False)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;frac&#39;, [0, 1.])
                self._fracs_[ipdf + 2 * len(self._signal_pdf_)] = zfit.Parameter(
                    f&#39;{self._name_}_frac_bkg{ipdf}&#39;,
                    self._init_bkg_pars_[ipdf][&#39;frac&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;frac&#39;][0],
                    self._limits_bkg_pars_[ipdf][&#39;frac&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;frac&#39;])

        self._total_pdf_ = zfit.pdf.SumPDF(self._signal_pdf_+self._refl_pdf_+self._background_pdf_, self._fracs_)

    def __build_total_pdf_binned(self):
        &#34;&#34;&#34;
        Helper function to compose the total pdf binned from unbinned
        &#34;&#34;&#34;

        # for binned data, obs already contains the wanted binning
        if self._data_handler_.get_is_binned():
            obs = self._data_handler_.get_obs()
        # for unbinned data, one needs to impose a binning
        else:
            obs = self._data_handler_.get_binned_obs_from_unbinned_data()

        self._total_pdf_binned_ = zfit.pdf.BinnedFromUnbinnedPDF(self._total_pdf_, obs)

    def __prefit(self):
        &#34;&#34;&#34;
        Helper function to perform a prefit to the sidebands
        &#34;&#34;&#34;
        # pylint: disable=fixme
        #TODO: implement me
        Logger(&#39;Prefit step to be implemented&#39;, &#39;WARNING&#39;)

    def __get_all_fracs(self):
        &#34;&#34;&#34;
        Helper function to get all fractions

        Returns
        -------------------------------------------------
        signal_fracs: list
            fractions of the signal pdfs
        background_fracs: list
            fractions of the background pdfs
        refl_fracs: list
            fractions of the reflected signal pdfs
        signal_err_fracs: list
            errors of fractions of the signal pdfs
        bkg_err_fracs: list
            errors of fractions of the background pdfs
        refl_err_fracs: list
            errors of fractions of the reflected signal pdfs
        &#34;&#34;&#34;
        signal_fracs, bkg_fracs, refl_fracs, signal_err_fracs, bkg_err_fracs, refl_err_fracs = ([] for _ in range(6))
        for frac_par in self._fracs_:
            if frac_par is None:
                continue
            par_name = frac_par.name
            if f&#39;{self._name_}_frac_signal&#39; in par_name:
                signal_fracs.append(self._fit_result_.params[par_name][&#39;value&#39;])
                signal_err_fracs.append(self._fit_result_.params[par_name][&#39;hesse&#39;][&#39;error&#39;])
                isgn = int(par_name.split(sep=f&#39;{self._name_}_frac_signal&#39;)[-1])
                refl_fracs.append(signal_fracs[-1] * self._refl_over_sgn_[isgn])
                refl_err_fracs.append(signal_err_fracs[-1] * self._refl_over_sgn_[isgn])
            elif f&#39;{self._name_}_frac_bkg&#39; in par_name:
                bkg_fracs.append(self._fit_result_.params[par_name][&#39;value&#39;])
                bkg_err_fracs.append(self._fit_result_.params[par_name][&#39;hesse&#39;][&#39;error&#39;])

        if len(signal_fracs) == len(bkg_fracs) == len(refl_fracs) == 0:
            signal_fracs.append(1.)
            signal_err_fracs.append(0.)

        return signal_fracs, bkg_fracs, refl_fracs, signal_err_fracs, bkg_err_fracs, refl_err_fracs

    def mass_zfit(self):
        &#34;&#34;&#34;
        Perform a mass fit with the zfit library

        Returns
        -------------------------------------------------
        fit_result: zfit.minimizers.fitresult.FitResult
            The fit result
        &#34;&#34;&#34;

        if self._data_handler_ is None:
            Logger(&#39;Data handler not specified&#39;, &#39;FATAL&#39;)

        self.__build_total_pdf()
        self.__build_total_pdf_binned()
        # pylint: disable=fixme
        self.__prefit() #TODO: implement me

        if self._data_handler_.get_is_binned():
            # chi2 loss
            if self._chi2_loss_:
                loss = zfit.loss.BinnedChi2(self._total_pdf_binned_, self._data_handler_.get_binned_data())
            # nll loss
            else:
                loss = zfit.loss.BinnedNLL(self._total_pdf_binned_, self._data_handler_.get_binned_data())
        else:
            loss = zfit.loss.UnbinnedNLL(model=self._total_pdf_, data=self._data_handler_.get_data())

        self._fit_result_ = self._minimizer_.minimize(loss=loss)
        Logger(self._fit_result_, &#39;RESULT&#39;)

        if self._fit_result_.hesse() == {}:
            if self._fit_result_.hesse(method=&#39;hesse_np&#39;) == {}:
                Logger(&#39;Impossible to compute hesse error&#39;, &#39;FATAL&#39;)

        norm = self._data_handler_.get_norm()
        if len(self._fracs_) == 0:
            self._rawyield_ = self._data_handler_.get_norm()
            self._rawyield_err_ = np.sqrt(self._rawyield_)
        else:
            for ipdf, _ in enumerate(self._signal_pdf_):
                if len(self._background_pdf_) &gt; 0 or ipdf &lt; len(self._signal_pdf_) - 1:
                    self._rawyield_[ipdf] = self._fit_result_.params[
                        f&#39;{self._name_}_frac_signal{ipdf}&#39;][&#39;value&#39;] * norm
                    self._rawyield_err_[ipdf] = self._fit_result_.params[
                        f&#39;{self._name_}_frac_signal{ipdf}&#39;][&#39;hesse&#39;][&#39;error&#39;] * norm
                else:
                    frac, frac_err = 0., 0.
                    for ipdf2 in range(len(self._signal_pdf_)-1):
                        frac += self._fit_result_.params[
                            f&#39;{self._name_}_frac_signal{ipdf2}&#39;][&#39;value&#39;]
                        frac_err += np.sqrt(self._fit_result_.params[
                            f&#39;{self._name_}_frac_signal{ipdf2}&#39;][&#39;hesse&#39;][&#39;error&#39;])
                    self._rawyield_[ipdf] = frac * norm
                    self._rawyield_err_[ipdf] = frac_err * norm

        return self._fit_result_

    # pylint: disable=too-many-statements, too-many-locals
    def plot_mass_fit(self, **kwargs):
        &#34;&#34;&#34;
        Plot the mass fit

        Parameters
        -------------------------------------------------
        **kwargs: dict
            Additional optional arguments:

            - style: str
                style to be used (see https://github.com/scikit-hep/mplhep for more details)

            - logy: bool
                log scale in y axis

            - figsize: tuple
                size of the figure

            - axis_title: str
                x-axis title

            - show_extra_info: bool
                show mu, sigma, chi2/ndf, signal, bkg, signal/bkg, significance

            - extra_info_massnsigma: float
                number of sigmas for extra info

            - extra_info_massnhwhm: float
                number of hwhms for extra info (alternative to extra_info_massnsigma)

            - extra_info_massrange: list
                mass range limits for extra info (alternative to extra_info_massnsigma)

            - extra_info_loc: list
                location of extra info (one for chi2 and one for other info)

            - num: int
                number of bins to plot pdfs converted into histograms

        Returns
        -------------------------------------------------
        fig: matplotlib.figure.Figure
            figure containing the mass fit plot
        &#34;&#34;&#34;

        style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
        logy = kwargs.get(&#39;logy&#39;, False)
        figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
        bins = self._data_handler_.get_nbins()
        axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())
        show_extra_info = kwargs.get(&#39;show_extra_info&#39;, False)
        num = kwargs.get(&#39;num&#39;, 10000)
        mass_range = kwargs.get(&#39;extra_info_massrange&#39;, None)
        nhwhm = kwargs.get(&#39;extra_info_massnhwhm&#39;, None)
        nsigma = kwargs.get(&#39;extra_info_massnsigma&#39;, 3)
        loc = kwargs.get(&#39;extra_info_loc&#39;, [&#39;upper left&#39;, &#39;lower right&#39;])

        mplhep.style.use(style)

        obs = self._data_handler_.get_obs()
        limits = self._data_handler_.get_limits()

        fig, axs = plt.subplots(figsize=figsize)

        hdata = self._data_handler_.to_hist(lower_edge=limits[0],
                                            upper_edge=limits[1],
                                            nbins=bins,
                                            varname=self._data_handler_.get_var_name())

        hdata.plot(yerr=True, color=&#39;black&#39;, histtype=&#39;errorbar&#39;, label=&#39;data&#39;)
        bin_sigma = (limits[1] - limits[0]) / bins
        norm = self._data_handler_.get_norm() * bin_sigma

        x_plot = np.linspace(limits[0], limits[1], num=num)
        total_func = zfit.run(self._total_pdf_.pdf(x_plot, norm_range=obs))
        signal_funcs, refl_funcs, bkg_funcs = ([] for _ in range(3))
        for signal_pdf in self._signal_pdf_:
            signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
        for refl_pdf in self._refl_pdf_:
            refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))
        for bkg_pdf in self._background_pdf_:
            bkg_funcs.append(zfit.run(bkg_pdf.pdf(x_plot, norm_range=obs)))

        signal_fracs, bkg_fracs, refl_fracs, _, _, _ = self.__get_all_fracs()

        # first draw backgrounds
        for ibkg, bkg_func in enumerate(bkg_funcs):
            if ibkg &lt; len(bkg_fracs) - 1:
                plt.plot(x_plot, bkg_func * norm * bkg_fracs[ibkg], color=self._bkg_cmap_(ibkg),
                         ls=&#39;--&#39;, label=f&#39;background {ibkg}&#39;)
            else:
                plt.plot(x_plot, bkg_func * norm * (1-sum(bkg_fracs)-sum(signal_fracs)-sum(refl_fracs)),
                         color=&#39;firebrick&#39;, ls=&#39;--&#39;, label=f&#39;background {ibkg}&#39;)
        # then draw signals
        for isgn, (signal_func, frac) in enumerate(zip(signal_funcs, signal_fracs)):
            plt.plot(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn))
            plt.fill_between(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn),
                             alpha=0.5, label=f&#39;signal {isgn}&#39;)

        # finally draw reflected signals (if any)
        for irefl, (refl_func, frac) in enumerate(zip(refl_funcs, refl_fracs)):
            if self._name_refl_pdf_[irefl] is None:
                continue
            plt.plot(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl))
            plt.fill_between(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl),
                             alpha=0.5, label=f&#39;reflected signal {irefl}&#39;)

        plt.plot(x_plot, total_func * norm, color=&#39;xkcd:blue&#39;, label=&#39;total fit&#39;)
        plt.xlim(limits[0], limits[1])
        plt.xlabel(axis_title)
        plt.ylabel(rf&#39;counts / {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#39;)
        plt.legend(loc=&#39;best&#39;)
        if logy:
            plt.yscale(&#39;log&#39;)
            plt.ylim(min(total_func) * norm / 5, max(total_func) * norm * 5)

        if show_extra_info:
            # info on chi2/ndf
            chi2 = self.get_chi2()
            ndf = self.get_ndf()
            anchored_text_chi2 = AnchoredText(fr&#39;$\chi^2 / \mathrm{{ndf}} =${chi2:.2f} / {ndf}&#39;,
                                              loc = loc[0],
                                              frameon=False)
            # signal and background info for all signals
            text = []
            for idx, _ in enumerate(self._name_signal_pdf_):
                mass, mass_unc = self.get_mass(idx)
                sigma, sigma_unc = None, None
                gamma, gamma_unc = None, None
                if self._name_signal_pdf_[idx] in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;voigtian&#39;, &#39;hist&#39;]:
                    sigma, sigma_unc = self.get_sigma(idx)
                if self._name_signal_pdf_[idx] in [&#39;cauchy&#39;, &#39;voigtian&#39;]:
                    gamma, gamma_unc = self.get_signal_parameter(idx, &#39;gamma&#39;)
                extra_info = fr&#39;signal{idx}&#39;&#39;\n&#39; + fr&#39;  $\mu = {mass*1000:.1f}\pm{mass_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
                if sigma is not None:
                    extra_info += fr&#39;  $\sigma = {sigma*1000:.1f}\pm{sigma_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
                if gamma is not None:
                    extra_info += fr&#39;  $\Gamma = {gamma*1000:.1f}\pm{gamma_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
                if mass_range is not None:
                    signal, signal_err = self.get_signal(idx=idx, min=mass_range[0], max=mass_range[1])
                    bkg, bkg_err = self.get_background(idx=idx, min=mass_range[0], max=mass_range[1])
                    s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, min=mass_range[0],
                                                                             max=mass_range[1])
                    signif, signif_err = self.get_significance(idx=idx, min=mass_range[0],
                                                                           max=mass_range[1])
                    interval = f&#39;[{mass_range[0]:.3f}, {mass_range[1]:.3f}]&#39;
                    extra_info += fr&#39;  $S({interval})={signal:.0f} \pm {signal_err:.0f}$&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $B({interval})={bkg:.0f} \pm {bkg_err:.0f}$&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $S/B({interval})={s_over_b:.2f} \pm {s_over_b_err:.2f}$&#39;&#39;\n&#39;
                    extra_info += fr&#39;  Signif.$({interval})={signif:.1f} \pm {signif_err:.1f}$&#39;
                elif nhwhm is not None:
                    signal, signal_err = self.get_signal(idx=idx, nhwhm=nhwhm)
                    bkg, bkg_err = self.get_background(idx=idx, nhwhm=nhwhm)
                    s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, nhwhm=nhwhm)
                    signif, signif_err = self.get_significance(idx=idx, nhwhm=nhwhm)
                    extra_info += fr&#39;  $S=${signal:.0f} $\pm$ {signal_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $B({nhwhm}~\mathrm{{HWHM}})=${bkg:.0f} $\pm$ {bkg_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $S/B({nhwhm}~\mathrm{{HWHM}})=${s_over_b:.2f} $\pm$ {s_over_b_err:.2f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  Signif.$({nhwhm}~\mathrm{{HWHM}})=${signif:.1f} $\pm$ {signif_err:.1f}&#39;
                else:
                    signal, signal_err = self.get_signal(idx=idx, nsigma=nsigma)
                    bkg, bkg_err = self.get_background(idx=idx, nsigma=nsigma)
                    s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, nsigma=nsigma)
                    signif, signif_err = self.get_significance(idx=idx, nsigma=nsigma)
                    extra_info += fr&#39;  $S=${signal:.0f} $\pm$ {signal_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $B({nsigma}\sigma)=${bkg:.0f} $\pm$ {bkg_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $S/B({nsigma}\sigma)=${s_over_b:.2f} $\pm$ {s_over_b_err:.2f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  Signif.$({nsigma}\sigma)=${signif:.1f} $\pm$ {signif_err:.1f}&#39;
                text.append(extra_info)
            concatenated_text = &#39;\n&#39;.join(text)
            anchored_text_signal = AnchoredText(concatenated_text, loc = loc[1], frameon=False)

            axs.add_artist(anchored_text_chi2)
            axs.add_artist(anchored_text_signal)

        return fig

    # pylint: disable=too-many-statements, too-many-locals
    def dump_to_root(self, filename, **kwargs):
        &#34;&#34;&#34;
        Plot the mass fit

        Parameters
        -------------------------------------------------
        filename: str
            Name of output ROOT file

        **kwargs: dict
            Additional optional arguments:

            - axis_title: str
                x-axis title

            - num: int
                number of bins to plot pdfs converted into histograms

            - option: str
                option (recreate or update)


            - suffix: str
                suffix to append to objects
        &#34;&#34;&#34;

        num = kwargs.get(&#39;num&#39;, 10000)
        suffix = kwargs.get(&#39;suffix&#39;, &#39;&#39;)
        option = kwargs.get(&#39;option&#39;, &#39;recreate&#39;)
        bins = self._data_handler_.get_nbins()
        obs = self._data_handler_.get_obs()
        limits = self._data_handler_.get_limits()

        hdata = self._data_handler_.to_hist(lower_edge=limits[0],
                                            upper_edge=limits[1],
                                            nbins=bins,
                                            varname=self._data_handler_.get_var_name())
        # write data
        self.__write_data(hdata, f&#39;hdata{suffix}&#39;, filename, option)

        bin_sigma = (limits[1] - limits[0]) / bins
        norm = self._data_handler_.get_norm() * bin_sigma
        x_plot = np.linspace(limits[0], limits[1], num=num)

        total_func = zfit.run(self._total_pdf_.pdf(x_plot, norm_range=obs))
        # write total_func
        self.__write_pdf(histname=f&#39;total_func{suffix}&#39;, weight=total_func * norm, num=num,
                         filename=filename, option=&#39;update&#39;)

        signal_funcs, bkg_funcs, refl_funcs = ([] for _ in range(3))
        for signal_pdf in self._signal_pdf_:
            signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
        for refl_pdf in self._refl_pdf_:
            refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))
        for bkg_pdf in self._background_pdf_:
            bkg_funcs.append(zfit.run(bkg_pdf.pdf(x_plot, norm_range=obs)))

        signal_fracs, bkg_fracs, refl_fracs, _, _, _ = self.__get_all_fracs()

        # first write backgrounds
        for ibkg, bkg_func in enumerate(bkg_funcs):
            if ibkg &lt; len(bkg_fracs) - 1:
                self.__write_pdf(histname=f&#39;bkg_{ibkg}{suffix}&#39;,
                                 weight=bkg_func * norm * bkg_fracs[ibkg],
                                 num=num, filename=filename, option=&#39;update&#39;)
            else:
                self.__write_pdf(histname=f&#39;bkg_{ibkg}{suffix}&#39;,
                               weight=bkg_func * norm * (1-sum(bkg_fracs)-sum(signal_fracs)-sum(refl_fracs)),
                               num=num, filename=filename, option=&#39;update&#39;)
        # then write signals
        for isgn, (frac, signal_func) in enumerate(zip(signal_funcs, signal_fracs)):
            self.__write_pdf(histname=f&#39;signal_{isgn}{suffix}&#39;,
                           weight=signal_func * norm * frac,
                           num=num, filename=filename, option=&#39;update&#39;)

        # finally write reflected signals
        for irefl, (frac, refl_func) in enumerate(zip(refl_funcs, refl_fracs)):
            if self._name_refl_pdf_[irefl] is None:
                continue
            self.__write_pdf(histname=f&#39;refl_{irefl}{suffix}&#39;,
                           weight=refl_func * norm * frac,
                           num=num, filename=filename, option=&#39;update&#39;)

    @property
    def get_fit_result(self):
        &#34;&#34;&#34;
        Get the fit result

        Returns
        -------------------------------------------------
        fit_result: zfit.minimizers.fitresult.FitResult
            The fit result
        &#34;&#34;&#34;
        return self._fit_result_

    def get_ndf(self):
        &#34;&#34;&#34;
        Get the number of degrees of freedom for chi2 fit
        ndf = nbins - nfreeparams - 1
        -1 because the data sample size is fixed

        Returns
        -------------------------------------------------
        ndf: int
            The number of degrees of freedom
        &#34;&#34;&#34;
        nbins = self._data_handler_.get_nbins()
        nfreeparams =  len(self._fit_result_.params)
        self._ndf_ = nbins - nfreeparams - 1
        return self._ndf_

    def get_chi2(self):
        &#34;&#34;&#34;
        Get chi2 for binned data

        Returns
        -------------------------------------------------
        chi2: float
            chi2
        &#34;&#34;&#34;

        chi2 = 0
        norm = self._data_handler_.get_norm()
        if self._data_handler_.get_is_binned():
            # for chi2 loss, just retrieve loss value in fit result
            if self._chi2_loss_:
                return float(self._fit_result_.loss.value())

            # for nll loss, compute chi2 &#34;by hand&#34;
            # access normalized data values and errors for all bins
            binned_data = self._data_handler_.get_binned_data()
            data_values = binned_data.values()
            data_variances = binned_data.variances()
            # access model predicted values
            model_values = self._total_pdf_binned_.values()*norm
            # compute chi2
            for (data, model, data_variance) in zip(data_values, model_values, data_variances):
                chi2 += (data - model)**2/data_variance
            return chi2

        # for unbinned data
        data_values = self._data_handler_.get_binned_data_from_unbinned_data()
        # access model predicted values
        model_values = self._total_pdf_binned_.values()*norm
        # compute chi2
        for (data, model) in zip(data_values, model_values):
            chi2 += (data - model)**2/data

        return float(chi2)

    def get_chi2_ndf(self):
        &#34;&#34;&#34;
        Get the reduced chi2 (chi2 divided by number of degrees of freedom)
        for binned data

        Returns
        -------------------------------------------------
        chi2_ndf: float
            The reduced chi2
        &#34;&#34;&#34;
        return self.get_chi2()/self.get_ndf()

    def get_raw_residuals(self):
        &#34;&#34;&#34;
        Get the raw residuals (data_value - bkg_model_value) for all bins

        Returns
        -------------------------------------------------
        residuals: array[float]
            The residuals
        &#34;&#34;&#34;

        bins = self._data_handler_.get_nbins()
        norm = self._data_handler_.get_norm()
        residuals = [None]*bins
        background_pdf_binned_ = [None for _ in enumerate(self._name_background_pdf_)]
        model_bkg_values = [None for _ in enumerate(self._name_background_pdf_)]

        # access normalized data values and errors for all bins
        if self._data_handler_.get_is_binned():
            binned_data = self._data_handler_.get_binned_data()
            data_values = binned_data.values()
            variances = binned_data.variances()
            obs = self._data_handler_.get_obs()
        else:
            data_values = self._data_handler_.get_binned_data_from_unbinned_data()
            variances = data_values # poissonian errors
            obs = self._data_handler_.get_binned_obs_from_unbinned_data()

        # get background fractions
        if len(self._background_pdf_) == 1:
            signal_fracs, _, refl_fracs, _, _, _ = self.__get_all_fracs()
            bkg_fracs = [1 - sum(signal_fracs) - sum(refl_fracs)]
        else:
            _, bkg_fracs, _, _, _, _ = self.__get_all_fracs()
        # access model predicted values for background
        for ipdf, _ in enumerate(self._name_background_pdf_):
            background_pdf_binned_[ipdf] = zfit.pdf.BinnedFromUnbinnedPDF(self._background_pdf_[ipdf], obs)
            model_bkg_values[ipdf] = background_pdf_binned_[ipdf].values()*bkg_fracs[ipdf]*norm
        # compute residuals
        for ibin, data in enumerate(data_values):
            residuals[ibin] = float(data)
            for ipdf, _ in enumerate(self._name_background_pdf_):
                residuals[ibin] -= model_bkg_values[ipdf][ibin]

        return residuals, variances

    def plot_raw_residuals(self, **kwargs):
        &#34;&#34;&#34;
        Plot the raw residuals

        Parameters
        -------------------------------------------------
        **kwargs: dict
            Additional optional arguments:

            - style: str
                style to be used (see https://github.com/scikit-hep/mplhep for more details)

            - figsize: tuple
                size of the figure

            - axis_title: str
                x-axis title

        Returns
        -------------------------------------------------
        fig: matplotlib.figure.Figure
            figure containing the raw residuals plot
        &#34;&#34;&#34;

        style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
        figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
        axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())

        mplhep.style.use(style)

        obs = self._data_handler_.get_obs()
        limits = self._data_handler_.get_limits()

        fig = plt.figure(figsize=figsize)

        residuals, variances = self.get_raw_residuals()
        # draw residuals
        plt.errorbar(
            self._data_handler_.get_bin_center(),
            residuals,
            xerr = None,
            yerr = np.sqrt(variances),
            linestyle = &#34;None&#34;,
            elinewidth = 1,
            capsize = 0,
            color = &#34;black&#34;,
            marker = &#34;o&#34;,
            markersize = 5,
            label = &#34;residuals&#34;
        )
        bins = self._data_handler_.get_nbins()
        bin_sigma = (limits[1] - limits[0]) / bins
        norm = self._data_handler_.get_norm() * bin_sigma

        x_plot = np.linspace(limits[0], limits[1], num=1000)
        signal_funcs, refl_funcs = ([] for _ in range(2))
        for signal_pdf in self._signal_pdf_:
            signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
        for refl_pdf in self._refl_pdf_:
            refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))

        signal_fracs, _, refl_fracs, _, _, _ = self.__get_all_fracs()

        # draw signals
        for isgn, (signal_func, frac) in enumerate(zip(signal_funcs, signal_fracs)):
            plt.plot(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn))
            plt.fill_between(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn),
                             alpha=0.5, label=f&#39;signal {isgn}&#39;)

        # finally draw reflected signals (if any)
        is_there_refl = False
        for irefl, (refl_func, frac) in enumerate(zip(refl_funcs, refl_fracs)):
            if self._name_refl_pdf_[irefl] is None:
                continue
            is_there_refl = True
            plt.plot(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl))
            plt.fill_between(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl),
                             alpha=0.5, label=f&#39;reflected signal {irefl}&#39;)

        # draw signal + reflected signals (if any)
        if is_there_refl:
            for isgn, (signal_func, refl_func, frac_sgn, frac_refl) in enumerate(
                zip(signal_funcs, refl_funcs, signal_fracs, refl_fracs)):
                plt.plot(x_plot, (signal_func * frac_sgn + frac_refl * refl_func) * norm,
                        color=&#39;xkcd:blue&#39;, label=&#39;total - bkg&#39;)


        plt.xlim(limits[0], limits[1])
        plt.xlabel(axis_title)
        plt.ylabel(rf&#39;(data - fitted bkg) / {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#39;)
        plt.legend(loc=&#39;best&#39;)

        return fig

    def get_std_residuals(self):
        &#34;&#34;&#34;
        Get the standardized residuals
        (data_value - bkg_model_value)/ sigma_data for all bins

        Returns
        -------------------------------------------------
        residuals: array[float]
            The standardized residuals
        &#34;&#34;&#34;

        bins = self._data_handler_.get_nbins()
        norm = self._data_handler_.get_norm()
        residuals, residuals_variances = [None]*bins, [None]*bins

        # access normalized data values and errors for all bins
        if self._data_handler_.get_is_binned():
            binned_data = self._data_handler_.get_binned_data()
            data_values = binned_data.values()
            variances = binned_data.variances()
        else:
            data_values = self._data_handler_.get_binned_data_from_unbinned_data()
            variances = data_values # poissonian errors

        # access model predicted values for background
        self.__build_total_pdf_binned()
        model_values = self._total_pdf_binned_.values()*norm
        for ibin, (data, model, variance) in enumerate(zip(data_values, model_values, variances)):
            if variance == 0:
                Logger(&#39;Null variance. Consider enlarging the bins.&#39;, &#39;FATAL&#39;)
            residuals[ibin] = float((data - model)/np.sqrt(variance))
            residuals_variances[ibin] = float(variance/np.sqrt(variance))

        return residuals, residuals_variances

    def plot_std_residuals(self, **kwargs):
        &#34;&#34;&#34;
        Plot the raw residuals

        Parameters
        -------------------------------------------------
        **kwargs: dict
            Additional optional arguments:

            - style: str
                style to be used (see https://github.com/scikit-hep/mplhep for more details)

            - figsize: tuple
                size of the figure

            - axis_title: str
                x-axis title

        Returns
        -------------------------------------------------
        fig: matplotlib.figure.Figure
            figure containing the raw residuals plot
        &#34;&#34;&#34;

        style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
        figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
        axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())

        mplhep.style.use(style)

        limits = self._data_handler_.get_limits()
        bins = self._data_handler_.get_nbins()
        bin_center = self._data_handler_.get_bin_center()

        fig = plt.figure(figsize=figsize)

        residuals, variances = self.get_std_residuals()
        # draw residuals
        plt.errorbar(bin_center,
                    residuals,
                    xerr = None,
                    yerr = np.sqrt(variances),
                    linestyle = &#34;None&#34;,
                    elinewidth = 1,
                    capsize = 0,
                    color = &#34;black&#34;,
                    marker = &#34;o&#34;,
                    markersize = 5,
                    label = None)

        # line at 0
        plt.plot([bin_center[0], bin_center[-1]], [0., 0.], lw=2, color=&#39;xkcd:blue&#39;)
        # line at -3 sigma
        plt.plot([bin_center[0], bin_center[-1]], [-3., -3.], lw=2, color=&#39;xkcd:red&#39;)
        # line at 3 sigma
        plt.plot([bin_center[0], bin_center[-1]], [3., 3.], lw=2, color=&#39;xkcd:red&#39;)

        plt.xlim(limits[0], limits[1])
        plt.xlabel(axis_title)
        plt.ylabel(fr&#34;$\dfrac{{ \mathrm{{data}} - \mathrm{{total \ fit}} }}{{ \sigma_{{ \mathrm{{data}} }} }}$&#34;
                   fr&#34;/ {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#34;)

        return fig

    def get_raw_yield(self, idx=0):
        &#34;&#34;&#34;
        Get the raw yield and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the raw yield to be returned (default: 0)

        Returns
        -------------------------------------------------
        raw_yield: float
            The raw yield obtained from the fit
        raw_yield_err: float
            The raw yield error obtained from the fit
        &#34;&#34;&#34;
        return self._rawyield_[idx], self._rawyield_err_[idx]

    def get_mass(self, idx=0):
        &#34;&#34;&#34;
        Get the mass and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the mass to be returned (default: 0)

        Returns
        -------------------------------------------------
        mass: float
            The mass value obtained from the fit
        mass_err: float
            The mass error obtained from the fit
        &#34;&#34;&#34;
        if &#39;hist&#39; in self._name_signal_pdf_[idx]:
            hist = self._signal_pdf_[idx].to_hist()
            bin_limits = hist.to_numpy()[1]
            centres = [0.5 * (minn + maxx) for minn, maxx in zip(bin_limits[1:],  bin_limits[:-1])]
            counts = hist.values()
            mass = np.average(centres, weights=counts)
            mass_err = 0.
        else:
            mass_name = &#39;m&#39; if self._name_signal_pdf_[idx] == &#39;cauchy&#39; else &#39;mu&#39;
            if self._fix_sgn_pars_[idx][mass_name]:
                mass = self._init_sgn_pars_[idx][mass_name]
                mass_err = 0.
            else:
                mass = self._fit_result_.params[f&#39;{self._name_}_{mass_name}_signal{idx}&#39;][&#39;value&#39;]
                mass_err = self._fit_result_.params[f&#39;{self._name_}_{mass_name}_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return mass, mass_err

    def get_sigma(self, idx=0):
        &#34;&#34;&#34;
        Get the sigma and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the sigma to be returned (default: 0)

        Returns
        -------------------------------------------------
        sigma: float
            The sigma value obtained from the fit
        sigma_err: float
            The sigma error obtained from the fit
        &#34;&#34;&#34;
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;voigtian&#39;, &#39;hist&#39;]:
            Logger(f&#39;Sigma parameter not defined for {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;ERROR&#39;)
            return 0., 0.

        # if histogram, the rms is used as proxy
        if &#39;hist&#39; in self._name_signal_pdf_[idx]:
            Logger(f&#39;RMS used as proxy for sigma parameter of {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;WARNING&#39;)
            mean = self.get_mass(idx)[0]
            hist = self._signal_pdf_[idx].to_hist()
            bin_limits = hist.to_numpy()[1]
            centres = [0.5 * (minn + maxx) for minn, maxx in zip(bin_limits[1:],  bin_limits[:-1])]
            counts = hist.values()
            sigma = np.sqrt(np.average((centres - mean)**2, weights=counts))
            sigma_err = 0.
        else:
            if self._fix_sgn_pars_[idx][&#39;sigma&#39;]:
                sigma = self._init_sgn_pars_[idx][&#39;sigma&#39;]
                sigma_err = 0.
            else:
                sigma = self._fit_result_.params[f&#39;{self._name_}_sigma_signal{idx}&#39;][&#39;value&#39;]
                sigma_err = self._fit_result_.params[f&#39;{self._name_}_sigma_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return sigma, sigma_err

    def get_hwhm(self, idx=0):
        &#34;&#34;&#34;
        Get the half width half maximum and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the sigma to be returned (default: 0)

        Returns
        -------------------------------------------------
        hwhm: float
            The sigma value obtained from the fit
        hwhm_err: float
            The sigma error obtained from the fit
        &#34;&#34;&#34;
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
            Logger(f&#39;HFWM parameter not defined for {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;ERROR&#39;)
            return 0., 0.

        if self._name_signal_pdf_[idx] == &#39;gaussian&#39;:
            mult_fact = np.sqrt(2 * np.log(2))
            hwhm, hwhm_err = self.get_sigma(idx)
            hwhm *= mult_fact
            hwhm_err *= mult_fact
        elif self._name_signal_pdf_[idx] == &#39;cauchy&#39;:
            hwhm, hwhm_err = self.get_signal_parameter(idx, &#39;gamma&#39;)
        elif self._name_signal_pdf_[idx] == &#39;voigtian&#39;:
            mult_fact = np.sqrt(2 * np.log(2))
            sigma, sigma_err = self.get_sigma(idx)
            sigma *= mult_fact
            sigma_err *= mult_fact
            gamma, gamma_err = self.get_signal_parameter(idx, &#39;gamma&#39;)
            hwhm = 0.5346 * gamma + np.sqrt(0.2166 * gamma**2 + sigma**2)
            # we neglect the correlation between sigma and gamma
            der_sigma = sigma / np.sqrt(0.0721663 + sigma**2)
            der_gamma = 0.5346 + (0.2166 * gamma) / np.sqrt(0.2166 * gamma**2 + sigma**2)
            hwhm_err = np.sqrt(der_sigma**2 * sigma_err**2 + der_gamma**2 * gamma_err**2)

        return hwhm, hwhm_err

    def get_signal_parameter(self, idx, par):
        &#34;&#34;&#34;
        Get a signal parameter and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the parameter to be returned (default: 0)
        par: str
            parameter to return

        Returns
        -------------------------------------------------
        parameter: float
            The parameter value obtained from the fit
        parameter_err: float
            The parameter error obtained from the fit

        &#34;&#34;&#34;

        if self._fix_sgn_pars_[idx][par]:
            parameter = self._init_sgn_pars_[idx][par]
            parameter_err = 0.
        else:
            parameter = self._fit_result_.params[f&#39;{self._name_}_{par}_signal{idx}&#39;][&#39;value&#39;]
            parameter_err = self._fit_result_.params[f&#39;{self._name_}_{par}_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return parameter, parameter_err

    def get_background_parameter(self, idx, par):
        &#34;&#34;&#34;
        Get a background parameter and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the parameter to be returned (default: 0)
        par: str
            parameter to return

        Returns
        -------------------------------------------------
        parameter: float
            The parameter value obtained from the fit
        parameter_err: float
            The parameter error obtained from the fit

        &#34;&#34;&#34;

        if self._fix_bkg_pars_[idx][par]:
            parameter = self._init_bkg_pars_[idx][par]
            parameter_err = 0.
        else:
            parameter = self._fit_result_.params[f&#39;{self._name_}_{par}_bkg{idx}&#39;][&#39;value&#39;]
            parameter_err = self._fit_result_.params[f&#39;{self._name_}_{par}_bkg{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return parameter, parameter_err

    def get_signal(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the signal and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be returned
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for signal computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for signal computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for signal computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        signal: float
            The signal value obtained from the fit
        signal_err: float
            The signal error obtained from the fit
        &#34;&#34;&#34;

        nsigma = kwargs.get(&#39;nsigma&#39;, 3.)
        nhwhm = kwargs.get(&#39;nhwhm&#39;, None)
        min_value = kwargs.get(&#39;min&#39;, None)
        max_value = kwargs.get(&#39;max&#39;, None)
        use_nsigma = True

        if nhwhm is not None and (min_value is not None or max_value is not None):
            Logger(&#39;I cannot compute the signal within a fixed mass interval and a number of HWFM&#39;, &#39;ERROR&#39;)
            return 0., 0.

        if min_value is not None and max_value is not None:
            use_nsigma = False

        if nhwhm is not None:
            use_nsigma = False
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
                Logger(&#39;HWHM not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            hwhm, _ = self.get_hwhm(idx)
            min_value = mass - nhwhm * hwhm
            max_value = mass + nhwhm * hwhm

        if use_nsigma:
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;hist&#39;]:
                Logger(&#39;Sigma not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            sigma, _ = self.get_sigma(idx)
            min_value = mass - nsigma * sigma
            max_value = mass + nsigma * sigma

        # pylint: disable=missing-kwoa
        signal = self._signal_pdf_[idx].integrate((min_value, max_value))

        signal_fracs, refl_fracs, _, signal_err_fracs, _, _ = self.__get_all_fracs()

        if len(self._background_pdf_) &gt; 0:
            frac = signal_fracs[idx]
            frac_err = signal_err_fracs[idx]
        else:
            if len(self._signal_pdf_) == 1:
                frac = 1.
                frac_err = 0.
            if idx &lt; len(signal_fracs):
                frac = signal_fracs[idx]
                frac_err = signal_err_fracs[idx]
            else:
                frac = 1. - sum(signal_fracs) - sum(refl_fracs)
                frac_err = np.sqrt(sum(list(err**2 for err in signal_err_fracs)))

        norm = self._data_handler_.get_norm()
        norm_err = norm * frac_err
        norm *= frac

        return float(signal * norm), float(signal * norm_err)

    def get_background(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the background and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be used to compute nsigma window
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for background computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for background computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for background computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        background: float
            The background value obtained from the fit
        background_err: float
            The background error obtained from the fit
        &#34;&#34;&#34;

        if not self._background_pdf_:
            Logger(&#39;Background not fitted&#39;, &#39;ERROR&#39;)
            return 0., 0.

        nsigma = kwargs.get(&#39;nsigma&#39;, 3.)
        nhwhm = kwargs.get(&#39;nhwhm&#39;, None)
        min_value = kwargs.get(&#39;min&#39;, None)
        max_value = kwargs.get(&#39;max&#39;, None)
        use_nsigma = True

        if nhwhm is not None and (min_value is not None or max_value is not None):
            Logger(&#39;I cannot compute the signal within a fixed mass interval and a number of HWFM&#39;, &#39;ERROR&#39;)
            return 0., 0.

        if min_value is not None and max_value is not None:
            use_nsigma = False

        if nhwhm is not None:
            use_nsigma = False
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
                Logger(&#39;HWHM not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            hwhm, _ = self.get_hwhm(idx)
            min_value = mass - nhwhm * hwhm
            max_value = mass + nhwhm * hwhm

        if use_nsigma:
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;hist&#39;]:
                Logger(&#39;Sigma not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            sigma, _ = self.get_sigma(idx)
            min_value = mass - nsigma * sigma
            max_value = mass + nsigma * sigma

        signal_fracs, bkg_fracs, refl_fracs, signal_err_fracs, bkg_err_fracs, _ = self.__get_all_fracs()

        # pylint: disable=missing-kwoa
        background, background_err = 0., 0.
        for idx2, bkg in enumerate(self._background_pdf_):

            if idx2 == len(self._background_pdf_) - 1:
                frac = 1. - sum(signal_fracs) - sum(refl_fracs)
                frac_err = np.sqrt(sum(list(err**2 for err in signal_err_fracs)))
            else:
                frac = bkg_fracs[idx2]
                frac_err = bkg_err_fracs[idx2]

            norm = self._data_handler_.get_norm()
            norm_err = norm * frac_err
            norm *= frac

            bkg_int = bkg.integrate((min_value, max_value))
            background += bkg_int * norm
            background_err += (bkg_int * norm_err)**2

        background_err = np.sqrt(background_err)

        return float(background), float(background_err)

    def get_signal_over_background(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the S/B ratio and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be used to compute nsigma window
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for signal and background computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for signal and background computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for signal and background computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        signal_over_background: float
            The S/B value obtained from the fit
        signal_over_background_err: float
            The S/B error obtained from the fit
        &#34;&#34;&#34;

        signal = self.get_signal(idx, **kwargs)
        bkg = self.get_background(idx, **kwargs)
        signal_over_background = signal[0]/bkg[0]
        signal_over_background_err = np.sqrt(signal[1]**2/signal[0]**2 + bkg[1]**2/bkg[0]**2)
        signal_over_background_err *= signal_over_background

        return signal_over_background, signal_over_background_err

    def get_significance(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the significance and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be used to compute nsigma window
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for signal and background computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for signal and background computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for signal and background computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        significance: float
            The significance value obtained from the fit
        significance_err: float
            The significance error obtained from the fit
        &#34;&#34;&#34;

        signal = self.get_signal(idx, **kwargs)
        bkg = self.get_background(idx, **kwargs)
        significance = signal[0]/np.sqrt(signal[0]+bkg[0])
        sig_plus_bkg = signal[0] + bkg[0]

        significance_err = significance*np.sqrt(
            (signal[1]**2 + bkg[1]**2) / (4. * sig_plus_bkg**2) + (
                bkg[0]/sig_plus_bkg) * signal[1]**2 / signal[0]**2)

        return significance, significance_err

    def set_particle_mass(self, idx, **kwargs):
        &#34;&#34;&#34;
        Set the particle mass

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        **kwargs: dict
            Additional optional arguments:

            - mass: float
                The mass of the particle

            - pdg_id: int
                PDG ID of the particle (alternative to mass)

            - pdg_name: str
                Name of the particle (alternative to mass)

            - limits: list
                minimum and maximum limits for the mass parameter

            - fix: bool
                fix the mass parameter
        &#34;&#34;&#34;
        mass_name = &#39;m&#39; if self._name_signal_pdf_[idx] == &#39;cauchy&#39; else &#39;mu&#39;
        mass = 0.
        if &#39;mass&#39; in kwargs:
            mass = kwargs[&#39;mass&#39;]
        elif &#39;pdg_id&#39; in kwargs:
            mass = Particle.from_pdgid(kwargs[&#39;pdg_id&#39;]).mass*1e-3
        elif &#39;pdg_name&#39; in kwargs:
            mass = Particle.from_name(kwargs[&#39;pdg_name&#39;]).mass*1e-3
        else:
            Logger(f&#39;&#34;mass&#34;, &#34;pdg_id&#34;, and &#34;pdg_name&#34; not provided, mass value for signal {idx} will not be set&#39;,
                   &#39;ERROR&#39;)
        self._init_sgn_pars_[idx][mass_name] = mass
        if &#39;limits&#39; in kwargs:
            self._limits_sgn_pars_[idx][mass_name] = kwargs[&#39;limits&#39;]
        if &#39;fix&#39; in kwargs:
            self._fix_sgn_pars_[idx][mass_name] = kwargs[&#39;fix&#39;]

    def set_signal_initpar(self, idx, par_name, init_value, **kwargs):
        &#34;&#34;&#34;
        Set a signal parameter

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        par_name: str
            The name of the parameter to be set
        init_value: float
            The value of parameter to be set
        **kwargs: dict
            Additional optional arguments:

            - limits: list
                minimum and maximum limits for the parameter

            - fix: bool
                fix the parameter to init_value
        &#34;&#34;&#34;
        self._init_sgn_pars_[idx][par_name] = init_value
        if &#39;limits&#39; in kwargs:
            self._limits_sgn_pars_[idx][par_name] = kwargs[&#39;limits&#39;]
        if &#39;fix&#39; in kwargs:
            self._fix_sgn_pars_[idx][par_name] = kwargs[&#39;fix&#39;]

    def set_background_initpar(self, idx, par_name, init_value, **kwargs):
        &#34;&#34;&#34;
        Set a background parameter

        Parameters
        -------------------------------------------------
        idx: int
            Index of the background
        par_name: str
            The name of the parameter to be set
        init_value: float
            The value of parameter to be set
        **kwargs: dict
            Additional optional arguments:

            - limits: list
                minimum and maximum limits for the parameter

            - fix: bool
                fix the mass parameter
        &#34;&#34;&#34;
        self._init_bkg_pars_[idx][par_name] = init_value
        if &#39;limits&#39; in kwargs:
            self._limits_bkg_pars_[idx][par_name] = kwargs[&#39;limits&#39;]
        if &#39;fix&#39; in kwargs:
            self._fix_bkg_pars_[idx][par_name] = kwargs[&#39;fix&#39;]

    # pylint: disable=line-too-long
    def set_signal_template(self, idx, sample):
        &#34;&#34;&#34;
        Set sample and options for signal template

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        sample: flarefly.DataHandler
            Data sample for histogram template
        &#34;&#34;&#34;

        self._hist_signal_sample_[idx] = sample

    # pylint: disable=line-too-long
    def set_signal_kde(self, idx, sample, **kwargs):
        &#34;&#34;&#34;
        Set sample and options for signal kde

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        sample: flarefly.DataHandler
            Data sample for Kernel Density Estimation
        **kwargs: dict
            Arguments for kde options. See
            https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
            for more details
        &#34;&#34;&#34;

        self._kde_signal_sample_[idx] = sample
        self._kde_signal_option_[idx] = kwargs

    # pylint: disable=line-too-long
    def set_reflection_template(self, idx, sample, r_over_s):
        &#34;&#34;&#34;
        Set sample and options for reflected signal template

        Parameters
        -------------------------------------------------
        idx: int
            Index of the reflected signal
        sample: flarefly.DataHandler
            Data sample for histogram template
        r_over_s: float
            R/S ratio
        &#34;&#34;&#34;

        self._hist_refl_sample_[idx] = sample
        self._refl_over_sgn_[idx] = r_over_s

    # pylint: disable=line-too-long
    def set_reflection_kde(self, idx, sample, r_over_s, **kwargs):
        &#34;&#34;&#34;
        Set sample and options for reflected signal kde

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        sample: flarefly.DataHandler
            Data sample for Kernel Density Estimation
        r_over_s: float
            R/S ratio
        **kwargs: dict
            Arguments for kde options. See
            https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
            for more details
        &#34;&#34;&#34;

        self._kde_signal_sample_[idx] = sample
        self._kde_signal_option_[idx] = kwargs
        self._refl_over_sgn_[idx] = r_over_s

    # pylint: disable=line-too-long
    def set_background_template(self, idx, sample):
        &#34;&#34;&#34;
        Set sample and options for background template histogram

        Parameters
        -------------------------------------------------
        idx: int
            Index of the background
        sample: flarefly.DataHandler
            Data sample for template histogram
        &#34;&#34;&#34;

        self._hist_bkg_sample_[idx] = sample

    # pylint: disable=line-too-long
    def set_background_kde(self, idx, sample, **kwargs):
        &#34;&#34;&#34;
        Set sample and options for background kde

        Parameters
        -------------------------------------------------
        idx: int
            Index of the background
        sample: flarefly.DataHandler
            Data sample for Kernel Density Estimation
        **kwargs: dict
            Arguments for kde options. See
            https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
            for more details
        &#34;&#34;&#34;

        self._kde_bkg_sample_[idx] = sample
        self._kde_bkg_option_[idx] = kwargs

    def __write_data(self, hdata, histname=&#39;hdata&#39;, filename=&#39;output.root&#39;, option=&#39;recreate&#39;):
        &#34;&#34;&#34;
        Helper method to save a data histogram in a .root file (TH1D format)

        Parameters
        -------------------------------------------------
        hdata: hist
            Histogram containing the data

        histname: str
            Name of the histogram

        filename: str
            Name of the ROOT file

        option: str
            Option (recreate or update)
        &#34;&#34;&#34;
        if option not in [&#39;recreate&#39;, &#39;update&#39;]:
            Logger(&#39;Illegal option to save outputs in ROOT file!&#39;, &#39;FATAL&#39;)

        if option == &#39;recreate&#39;:
            with uproot.recreate(filename) as ofile:
                ofile[histname] = hdata
        else:
            with uproot.update(filename) as ofile:
                ofile[histname] = hdata

    def __write_pdf(self, histname, weight, num, filename=&#39;output.root&#39;, option=&#39;recreate&#39;):
        &#34;&#34;&#34;
        Helper method to save a pdf histogram in a .root file (TH1D format)

        Parameters
        -------------------------------------------------
        histname: str
            Name of the histogram

        weight: array[float]
            Array of weights for histogram bins

        num: int
            Number of bins to plot pdfs converted into histograms

        filename: str
            ROOT file name

        option: str
            Option (recreate or update)
        &#34;&#34;&#34;

        if option not in [&#39;recreate&#39;, &#39;update&#39;]:
            Logger(&#39;Illegal option to save outputs in ROOT file!&#39;, &#39;FATAL&#39;)

        limits = self._data_handler_.get_limits()
        x_plot = np.linspace(limits[0], limits[1], num=num)
        histo = Hist.new.Reg(num, limits[0], limits[1], name=self._data_handler_.get_var_name()).Double()
        histo.fill(x_plot, weight=weight)

        if option == &#39;recreate&#39;:
            with uproot.recreate(filename) as ofile:
                ofile[histname] = histo
        else:
            with uproot.update(filename) as ofile:
                ofile[histname] = histo</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="flarefly.fitter.F2MassFitter"><code class="flex name class">
<span>class <span class="ident">F2MassFitter</span></span>
<span>(</span><span>data_handler, name_signal_pdf, name_background_pdf, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to perform mass fits with the zfit library
<a href="https://github.com/zfit/zfit">https://github.com/zfit/zfit</a></p>
<p>Initialize the F2MassFitter class
Parameters</p>
<hr>
<dl>
<dt><strong><code>data_handler</code></strong> :&ensp;<code>flarefly.DataHandler</code></dt>
<dd>The data handler containing the data to fit</dd>
<dt><strong><code>name_signal_pdf</code></strong> :&ensp;<code>list</code></dt>
<dd>
<p>The list of names for the signal pdfs. The possible options are:</p>
<ul>
<li>
<p>'gaussian'</p>
</li>
<li>
<p>'doublegaus'</p>
</li>
<li>
<p>'crystalball'</p>
</li>
<li>
<p>'doublecb'</p>
</li>
<li>
<p>'cauchy'</p>
</li>
<li>
<p>'voigtian'</p>
</li>
<li>
<p>'kde_exact' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_grid' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_fft' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_isj' (requires to set the datasample and options)</p>
</li>
<li>
<p>'hist' (only for binned fits, requires to set the datasample)</p>
</li>
</ul>
</dd>
<dt><strong><code>name_background_pdf</code></strong> :&ensp;<code>list</code></dt>
<dd>
<p>The list of names of the background pdfs. The possible options are:</p>
<ul>
<li>
<p>'nobkg'</p>
</li>
<li>
<p>'expo'</p>
</li>
<li>
<p>'powlaw'</p>
</li>
<li>
<p>'expopow'</p>
</li>
<li>
<p>'chebpolN' (N is the order of the polynomial)</p>
</li>
<li>
<p>'kde_exact' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_grid' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_fft' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_isj' (requires to set the datasample and options)</p>
</li>
<li>
<p>'hist' (only for binned fits, requires to set the datasample)</p>
</li>
</ul>
</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>name_refl_pdf: list
The list of names of the signal pdfs. It must have the same length as the signal list.
The possible options are:</p>
<ul>
<li>
<p>'kde_exact' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_grid' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_fft' (requires to set the datasample and options)</p>
</li>
<li>
<p>'kde_isj' (requires to set the datasample and options)</p>
</li>
<li>
<p>'hist' (only for binned fits, requires to set the datasample)</p>
</li>
</ul>
</li>
<li>
<p>name: str
Optional name for the fitter,
needed in case of multiple fitters defined in the same script</p>
</li>
<li>
<p>chi2_loss: bool
chi2 minimization if True, nll minmization else
Default value to False</p>
</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class F2MassFitter:
    &#34;&#34;&#34;
    Class used to perform mass fits with the zfit library
    https://github.com/zfit/zfit
    &#34;&#34;&#34;

    # pylint: disable=too-many-statements
    def __init__(self, data_handler, name_signal_pdf, name_background_pdf, **kwargs):
        &#34;&#34;&#34;
        Initialize the F2MassFitter class
        Parameters
        -------------------------------------------------
        data_handler: flarefly.DataHandler
            The data handler containing the data to fit

        name_signal_pdf: list
            The list of names for the signal pdfs. The possible options are:

            - &#39;gaussian&#39;

            - &#39;doublegaus&#39;

            - &#39;crystalball&#39;

            - &#39;doublecb&#39;

            - &#39;cauchy&#39;

            - &#39;voigtian&#39;

            - &#39;kde_exact&#39; (requires to set the datasample and options)

            - &#39;kde_grid&#39; (requires to set the datasample and options)

            - &#39;kde_fft&#39; (requires to set the datasample and options)

            - &#39;kde_isj&#39; (requires to set the datasample and options)

            - &#39;hist&#39; (only for binned fits, requires to set the datasample)

        name_background_pdf: list
            The list of names of the background pdfs. The possible options are:

            - &#39;nobkg&#39;

            - &#39;expo&#39;

            - &#39;powlaw&#39;

            - &#39;expopow&#39;

            - &#39;chebpolN&#39; (N is the order of the polynomial)

            - &#39;kde_exact&#39; (requires to set the datasample and options)

            - &#39;kde_grid&#39; (requires to set the datasample and options)

            - &#39;kde_fft&#39; (requires to set the datasample and options)

            - &#39;kde_isj&#39; (requires to set the datasample and options)

            - &#39;hist&#39; (only for binned fits, requires to set the datasample)

        **kwargs: dict
            Additional optional arguments:

            - name_refl_pdf: list
                The list of names of the signal pdfs. It must have the same length as the signal list.
                The possible options are:

                - &#39;kde_exact&#39; (requires to set the datasample and options)

                - &#39;kde_grid&#39; (requires to set the datasample and options)

                - &#39;kde_fft&#39; (requires to set the datasample and options)

                - &#39;kde_isj&#39; (requires to set the datasample and options)

                - &#39;hist&#39; (only for binned fits, requires to set the datasample)

            - name: str
                Optional name for the fitter,
                needed in case of multiple fitters defined in the same script

            - chi2_loss: bool
                chi2 minimization if True, nll minmization else
                Default value to False
        &#34;&#34;&#34;

        self._data_handler_ = data_handler
        self._name_signal_pdf_ = name_signal_pdf
        self._name_background_pdf_ = name_background_pdf
        self._signal_pdf_ = [None for _ in enumerate(name_signal_pdf)]
        self._hist_signal_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_signal_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_signal_option_ = [None for _ in enumerate(name_signal_pdf)]
        if self._name_background_pdf_[0] == &#39;nobkg&#39;:
            self._background_pdf_ = []
            self._hist_bkg_sample_ = []
            self._kde_bkg_sample_ = []
            self._kde_bkg_option_ = []
        else:
            self._background_pdf_ = [None for _ in enumerate(name_background_pdf)]
            self._hist_bkg_sample_ = [None for _ in enumerate(name_background_pdf)]
            self._kde_bkg_sample_ = [None for _ in enumerate(name_background_pdf)]
            self._kde_bkg_option_ = [None for _ in enumerate(name_background_pdf)]
        self._name_refl_pdf_ = kwargs.get(&#39;name_refl_pdf&#39;, [None for _ in enumerate(name_signal_pdf)])
        if len(self._name_refl_pdf_) != len(self._name_signal_pdf_):
            Logger(&#39;List of pdfs for signals and reflections different! Exit&#39;, &#39;FATAL&#39;)
        self._refl_pdf_ = [None for _ in enumerate(name_signal_pdf)]
        self._hist_refl_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_refl_sample_ = [None for _ in enumerate(name_signal_pdf)]
        self._kde_refl_option_ = [None for _ in enumerate(name_signal_pdf)]
        self._refl_over_sgn_ = [0. for _ in enumerate(name_signal_pdf)]
        self._total_pdf_ = None
        self._total_pdf_binned_ = None
        self._fit_result_ = None
        self._init_sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._init_bkg_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._limits_sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._limits_bkg_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._fix_sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._fix_bkg_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._sgn_pars_ = [{} for _ in enumerate(name_signal_pdf)]
        self._bkg_pars_ = [{} for _ in enumerate(name_background_pdf)]
        if self._name_background_pdf_[0] == &#39;nobkg&#39;:
            self._fracs_ = [None for _ in range(2 * len(name_signal_pdf) - 1)]
        else:
            self._fracs_ = [None for _ in range(2 * len(name_signal_pdf) + len(name_background_pdf) - 1)]
        self._rawyield_ = [0. for _ in enumerate(name_signal_pdf)]
        self._rawyield_err_ = [0. for _ in enumerate(name_signal_pdf)]
        self._minimizer_ = zfit.minimize.Minuit(verbosity=7)
        self._name_ = kwargs.get(&#39;name&#39;, &#39;&#39;)
        self._ndf_ = None
        self._chi2_loss_ = kwargs.get(&#39;chi2_loss&#39;, False)
        self._base_sgn_cmap_ = plt.cm.get_cmap(&#39;viridis&#39;, len(self._signal_pdf_) * 4)
        self._sgn_cmap_ = ListedColormap(self._base_sgn_cmap_(np.linspace(0.4, 0.65, len(self._signal_pdf_))))
        self._base_bkg_cmap_ = plt.cm.get_cmap(&#39;gist_heat&#39;, len(self._background_pdf_) * 2)
        self._bkg_cmap_ = ListedColormap(self._base_bkg_cmap_(np.linspace(0.3, 0.8, len(self._background_pdf_))))
        self._base_refl_cmap_ = plt.cm.get_cmap(&#39;summer&#39;, len(self._refl_pdf_) * 2)
        self._refl_cmap_ = ListedColormap(self._base_refl_cmap_(np.linspace(0., 0.6, len(self._refl_pdf_))))

        zfit.settings.advanced_warnings.all = False
        zfit.settings.changed_warnings.all = False

    # pylint: disable=too-many-branches, too-many-statements
    def __build_signal_pdfs(self, obs):
        &#34;&#34;&#34;
        Helper function to compose the signal pdfs
        &#34;&#34;&#34;

        for ipdf, pdf_name in enumerate(self._name_signal_pdf_):
            if pdf_name == &#39;gaussian&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.Gauss(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;doublegaus&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma1&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma2&#39;, 0.100)
                self._init_sgn_pars_[ipdf].setdefault(&#39;frac1&#39;, 0.9)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma1&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma2&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;frac1&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma1&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma2&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;frac1&#39;, [0., 1.])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma1_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma1_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma1&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma1&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma1&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma1&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma2_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma2_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma2&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma2&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma2&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma1&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_frac1_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_frac1_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;frac1&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;frac1&#39;][0], self._limits_sgn_pars_[ipdf][&#39;frac1&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;frac1&#39;])
                self._signal_pdf_[ipdf] = cpdf.DoubleGauss(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma1=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma1_signal{ipdf}&#39;],
                    sigma2=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma2_signal{ipdf}&#39;],
                    frac1=self._sgn_pars_[ipdf][f&#39;{self._name_}_frac1_signal{ipdf}&#39;],
                )
            elif pdf_name == &#39;crystalball&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;alpha&#39;, 0.5)
                self._init_sgn_pars_[ipdf].setdefault(&#39;n&#39;, 1.)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;alpha&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;n&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;alpha&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;n&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_alpha_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_alpha_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;alpha&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;alpha&#39;][0], self._limits_sgn_pars_[ipdf][&#39;alpha&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;alpha&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_n_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_n_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;n&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;n&#39;][0], self._limits_sgn_pars_[ipdf][&#39;n&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;n&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.CrystalBall(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;],
                    alpha=self._sgn_pars_[ipdf][f&#39;{self._name_}_alpha_signal{ipdf}&#39;],
                    n=self._sgn_pars_[ipdf][f&#39;{self._name_}_n_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;doublecb&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;alphal&#39;, 0.5)
                self._init_sgn_pars_[ipdf].setdefault(&#39;nl&#39;, 1.)
                self._init_sgn_pars_[ipdf].setdefault(&#39;alphar&#39;, 0.5)
                self._init_sgn_pars_[ipdf].setdefault(&#39;nr&#39;, 1.)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;alphal&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;nl&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;alphar&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;nr&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;alphal&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;nl&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;alphar&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;nr&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_alphal_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_alphal_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;alphal&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;alphal&#39;][0], self._limits_sgn_pars_[ipdf][&#39;alphal&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;alphal&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_nl_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_nl_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;nl&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;nl&#39;][0], self._limits_sgn_pars_[ipdf][&#39;nl&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;nl&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_alphar_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_alphar_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;alphar&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;alphar&#39;][0], self._limits_sgn_pars_[ipdf][&#39;alphar&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;alphar&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_nr_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_nr_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;nr&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;nr&#39;][0], self._limits_sgn_pars_[ipdf][&#39;nr&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;nr&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.DoubleCB(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;],
                    alphal=self._sgn_pars_[ipdf][f&#39;{self._name_}_alphal_signal{ipdf}&#39;],
                    nl=self._sgn_pars_[ipdf][f&#39;{self._name_}_nl_signal{ipdf}&#39;],
                    alphar=self._sgn_pars_[ipdf][f&#39;{self._name_}_alphar_signal{ipdf}&#39;],
                    nr=self._sgn_pars_[ipdf][f&#39;{self._name_}_nr_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;cauchy&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;m&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, 0.010)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;m&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;m&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_m_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_m_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;m&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;m&#39;][0], self._limits_sgn_pars_[ipdf][&#39;m&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;m&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_gamma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;gamma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;gamma&#39;])
                self._signal_pdf_[ipdf] = zfit.pdf.Cauchy(
                    obs=obs,
                    m=self._sgn_pars_[ipdf][f&#39;{self._name_}_m_signal{ipdf}&#39;],
                    gamma=self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;]
                )
            elif pdf_name == &#39;voigtian&#39;:
                self._init_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, 1.865)
                self._init_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, 0.010)
                self._init_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, 0.010)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, False)
                self._fix_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, False)
                self._limits_sgn_pars_[ipdf].setdefault(&#39;mu&#39;, [0, 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;gamma&#39;, [0., 1.e6])
                self._limits_sgn_pars_[ipdf].setdefault(&#39;sigma&#39;, [0., 1.e6])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mu_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;mu&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;mu&#39;][0], self._limits_sgn_pars_[ipdf][&#39;mu&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;mu&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_gamma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;gamma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;gamma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;gamma&#39;])
                self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_sigma_signal{ipdf}&#39;, self._init_sgn_pars_[ipdf][&#39;sigma&#39;],
                    self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][0], self._limits_sgn_pars_[ipdf][&#39;sigma&#39;][1],
                    floating=not self._fix_sgn_pars_[ipdf][&#39;sigma&#39;])
                self._signal_pdf_[ipdf] = cpdf.Voigtian(
                    obs=obs,
                    mu=self._sgn_pars_[ipdf][f&#39;{self._name_}_mu_signal{ipdf}&#39;],
                    sigma=self._sgn_pars_[ipdf][f&#39;{self._name_}_sigma_signal{ipdf}&#39;],
                    gamma=self._sgn_pars_[ipdf][f&#39;{self._name_}_gamma_signal{ipdf}&#39;]
                )
            elif &#39;kde&#39; in pdf_name:
                if self._kde_signal_sample_[ipdf]:
                    if pdf_name == &#39;kde_exact&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimExact(self._kde_signal_sample_[ipdf].get_data(),
                                                                        obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                        name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                        **self._kde_signal_option_[ipdf])
                    elif pdf_name == &#39;kde_grid&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimGrid(self._kde_signal_sample_[ipdf].get_data(),
                                                                       obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                       name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                       **self._kde_signal_option_[ipdf])
                    elif pdf_name == &#39;kde_fft&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimFFT(self._kde_signal_sample_[ipdf].get_data(),
                                                                      obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                      name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                      **self._kde_signal_option_[ipdf])
                    elif pdf_name == &#39;kde_isj&#39;:
                        self._signal_pdf_[ipdf] = zfit.pdf.KDE1DimISJ(self._kde_signal_sample_[ipdf].get_data(),
                                                                      obs=self._kde_signal_sample_[ipdf].get_obs(),
                                                                      name=f&#39;{self._name_}_kde_signal{ipdf}&#39;,
                                                                      **self._kde_signal_option_[ipdf])
                else:
                    Logger(f&#39;Missing datasample for Kernel Density Estimation of signal {ipdf}!&#39;, &#39;FATAL&#39;)
            elif pdf_name == &#39;hist&#39;:
                if self._hist_signal_sample_[ipdf]:
                    self._signal_pdf_[ipdf] = zfit.pdf.SplinePDF(
                        zfit.pdf.HistogramPDF(self._hist_signal_sample_[ipdf].get_binned_data(),
                                              name=f&#39;{self._name_}_hist_signal{ipdf}&#39;),
                        order=3,
                        obs=obs
                    )
                else:
                    Logger(f&#39;Missing datasample for histogram template of signal {ipdf}!&#39;, &#39;FATAL&#39;)
            else:
                Logger(f&#39;Signal pdf {pdf_name} not supported&#39;, &#39;FATAL&#39;)

    def __build_background_pdfs(self, obs):
        &#34;&#34;&#34;
        Helper function to compose the background pdfs
        &#34;&#34;&#34;

        for ipdf, pdf_name in enumerate(self._name_background_pdf_):
            if pdf_name == &#39;nobkg&#39;:
                Logger(&#39;Performing fit with no bkg pdf&#39;, &#39;WARNING&#39;)
                break
            if pdf_name == &#39;expo&#39;:
                self._init_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, 0.1)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, [-1.e6, 1.e6])
                self._fix_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, False)
                self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_lam_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;lam&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;lam&#39;][0], self._limits_bkg_pars_[ipdf][&#39;lam&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;lam&#39;])
                self._background_pdf_[ipdf] = zfit.pdf.Exponential(
                    obs=obs,
                    lam=self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;]
                )
            elif &#39;chebpol&#39; in pdf_name:
                pol_degree = int(pdf_name.split(&#39;chebpol&#39;)[1])
                for deg in range(pol_degree + 1):
                    self._init_bkg_pars_[ipdf].setdefault(f&#39;c{deg}&#39;, 0.1)
                    self._limits_bkg_pars_[ipdf].setdefault(f&#39;c{deg}&#39;, [-1.e6, 1.e6])
                    self._fix_bkg_pars_[ipdf].setdefault(f&#39;c{deg}&#39;, False)
                    self._bkg_pars_[ipdf][f&#39;{self._name_}_c{deg}_bkg{ipdf}&#39;] = zfit.Parameter(
                        f&#39;{self._name_}_c{deg}_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][f&#39;c{deg}&#39;],
                        self._limits_bkg_pars_[ipdf][f&#39;c{deg}&#39;][0], self._limits_bkg_pars_[ipdf][f&#39;c{deg}&#39;][1],
                        floating=not self._fix_bkg_pars_[ipdf][f&#39;c{deg}&#39;])
                coeff0 = self._bkg_pars_[ipdf][f&#39;{self._name_}_c0_bkg{ipdf}&#39;]
                bkg_coeffs = [self._bkg_pars_[ipdf][f&#39;{self._name_}_c{deg}_bkg{ipdf}&#39;]
                              for deg in range(1, pol_degree + 1)]
                self._background_pdf_[ipdf] = zfit.pdf.Chebyshev(obs=obs, coeffs=bkg_coeffs, coeff0=coeff0)
            elif &#39;powlaw&#39; in pdf_name:
                self._init_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, Particle.from_pdgid(211).mass*1e-3) # pion mass as default
                self._init_bkg_pars_[ipdf].setdefault(&#39;power&#39;, 1.)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, [0., 1.e6])
                self._limits_bkg_pars_[ipdf].setdefault(&#39;power&#39;, [-1.e6, 1.e6])
                self._fix_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, True)
                self._fix_bkg_pars_[ipdf].setdefault(&#39;power&#39;, False)
                if self._data_handler_.get_limits()[0] &lt; self._init_bkg_pars_[ipdf][&#34;mass&#34;]:
                    Logger(&#39;The mass parameter in powlaw cannot be smaller than the lower fit limit, please fix it.&#39;,
                           &#39;FATAL&#39;)
                self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mass_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;mass&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;mass&#39;][0], self._limits_bkg_pars_[ipdf][&#39;mass&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;mass&#39;])
                self._bkg_pars_[ipdf][f&#39;{self._name_}_power_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_power_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;power&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;power&#39;][0], self._limits_bkg_pars_[ipdf][&#39;power&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;power&#39;])
                self._background_pdf_[ipdf] = cpdf.Pow(
                    obs=obs,
                    mass=self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;],
                    power=self._bkg_pars_[ipdf][f&#39;{self._name_}_power_bkg{ipdf}&#39;]
                )
            elif &#39;expopow&#39; in pdf_name:
                self._init_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, Particle.from_pdgid(211).mass*1e-3) # pion mass as default
                self._init_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, 0.1)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, [0., 1.e6])
                self._limits_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, [-1.e6, 1.e6])
                self._fix_bkg_pars_[ipdf].setdefault(&#39;mass&#39;, True)
                self._fix_bkg_pars_[ipdf].setdefault(&#39;lam&#39;, False)
                if self._data_handler_.get_limits()[0] &lt; self._init_bkg_pars_[ipdf][&#34;mass&#34;]:
                    Logger(&#39;The mass parameter in expopow cannot be smaller than the lower fit limit, please fix it.&#39;,
                           &#39;FATAL&#39;)
                self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_mass_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;mass&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;mass&#39;][0], self._limits_bkg_pars_[ipdf][&#39;mass&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;mass&#39;])
                self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;] = zfit.Parameter(
                    f&#39;{self._name_}_lam_bkg{ipdf}&#39;, self._init_bkg_pars_[ipdf][&#39;lam&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;lam&#39;][0], self._limits_bkg_pars_[ipdf][&#39;lam&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;lam&#39;])
                self._background_pdf_[ipdf] = cpdf.ExpoPow(
                    obs=obs,
                    mass=self._bkg_pars_[ipdf][f&#39;{self._name_}_mass_bkg{ipdf}&#39;],
                    lam=self._bkg_pars_[ipdf][f&#39;{self._name_}_lam_bkg{ipdf}&#39;]
                )
            elif &#39;kde&#39; in pdf_name:
                if self._kde_bkg_sample_[ipdf]:
                    if pdf_name == &#39;kde_exact&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimExact(self._kde_bkg_sample_[ipdf].get_data(),
                                                                            obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                            name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                            **self._kde_bkg_option_[ipdf])
                    elif pdf_name == &#39;kde_grid&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimGrid(self._kde_bkg_sample_[ipdf].get_data(),
                                                                           obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                           name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                           **self._kde_bkg_option_[ipdf])
                    elif pdf_name == &#39;kde_fft&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimFFT(self._kde_bkg_sample_[ipdf].get_data(),
                                                                          obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                          name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                          **self._kde_bkg_option_[ipdf])
                    elif pdf_name == &#39;kde_isj&#39;:
                        self._background_pdf_[ipdf] = zfit.pdf.KDE1DimISJ(self._kde_bkg_sample_[ipdf].get_data(),
                                                                          obs=self._kde_bkg_sample_[ipdf].get_obs(),
                                                                          name=f&#39;{self._name_}_kde_bkg{ipdf}&#39;,
                                                                          **self._kde_bkg_option_[ipdf])

                else:
                    Logger(f&#39;Missing datasample for Kernel Density Estimation of background {ipdf}!&#39;, &#39;FATAL&#39;)
            elif pdf_name == &#39;hist&#39;:
                if self._hist_bkg_sample_[ipdf]:
                    self._background_pdf_[ipdf] = zfit.pdf.SplinePDF(
                        zfit.pdf.HistogramPDF(self._hist_bkg_sample_[ipdf].get_binned_data(),
                                              name=f&#39;{self._name_}_hist_background{ipdf}&#39;),
                        order=3,
                        obs=obs
                    )
                else:
                    Logger(f&#39;Missing datasample for histogram template of background {ipdf}!&#39;, &#39;FATAL&#39;)
            else:
                Logger(f&#39;Background pdf {pdf_name} not supported&#39;, &#39;FATAL&#39;)

    # pylint: disable=too-many-branches, too-many-statements
    def __build_reflection_pdfs(self, obs):
        &#34;&#34;&#34;
        Helper function to compose the reflection pdfs
        &#34;&#34;&#34;

        for ipdf, pdf_name in enumerate(self._name_refl_pdf_):
            if pdf_name is None: # by default we put a dummy pdf
                low = zfit.Parameter(f&#39;{self._name_}_low_refl{ipdf}&#39;,
                                     self._data_handler_.get_limits()[0],
                                     self._data_handler_.get_limits()[0]*0.99,
                                     self._data_handler_.get_limits()[0]*1.01,
                                     floating=False)
                high = zfit.Parameter(f&#39;{self._name_}_high_refl{ipdf}&#39;,
                                      self._data_handler_.get_limits()[1],
                                      self._data_handler_.get_limits()[1]*0.99,
                                      self._data_handler_.get_limits()[1]*1.01,
                                      floating=False)
                self._refl_pdf_[ipdf] = zfit.pdf.Uniform(obs=obs, low=low, high=high)
            elif &#39;kde&#39; in pdf_name:
                if self._kde_refl_sample_[ipdf]:
                    if pdf_name == &#39;kde_exact&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimExact(self._kde_refl_sample_[ipdf].get_data(),
                                                                      obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                      name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                      **self._kde_refl_option_[ipdf])
                    elif pdf_name == &#39;kde_grid&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimGrid(self._kde_refl_sample_[ipdf].get_data(),
                                                                     obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                     name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                     **self._kde_refl_option_[ipdf])
                    elif pdf_name == &#39;kde_fft&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimFFT(self._kde_refl_sample_[ipdf].get_data(),
                                                                    obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                    name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                    **self._kde_refl_option_[ipdf])
                    elif pdf_name == &#39;kde_isj&#39;:
                        self._refl_pdf_[ipdf] = zfit.pdf.KDE1DimISJ(self._kde_refl_sample_[ipdf].get_data(),
                                                                    obs=self._kde_refl_sample_[ipdf].get_obs(),
                                                                    name=f&#39;{self._name_}_kde_refl{ipdf}&#39;,
                                                                    **self._kde_refl_option_[ipdf])
                else:
                    Logger(f&#39;Missing datasample for Kernel Density Estimation of reflection {ipdf}!&#39;, &#39;FATAL&#39;)
            elif pdf_name == &#39;hist&#39;:
                if self._hist_refl_sample_[ipdf]:
                    self._refl_pdf_[ipdf] = zfit.pdf.SplinePDF(
                        zfit.pdf.HistogramPDF(self._hist_refl_sample_[ipdf].get_binned_data(),
                                              name=f&#39;{self._name_}_hist_refl{ipdf}&#39;),
                        order=3,
                        obs=obs
                    )
                else:
                    Logger(f&#39;Missing datasample for histogram template of reflections {ipdf}!&#39;, &#39;FATAL&#39;)
            else:
                Logger(f&#39;Reflection pdf {pdf_name} not supported&#39;, &#39;FATAL&#39;)

    def __build_total_pdf(self):
        &#34;&#34;&#34;
        Helper function to compose the total pdf
        &#34;&#34;&#34;

        obs = self._data_handler_.get_obs()

        # order of the pdfs is signal, background

        self.__build_signal_pdfs(obs)
        self.__build_background_pdfs(obs)
        self.__build_reflection_pdfs(obs)

        if len(self._signal_pdf_) + len(self._background_pdf_) == 1:
            self._total_pdf_ = self._signal_pdf_[0]
            return

        for ipdf, _ in enumerate(self._signal_pdf_):
            self._init_sgn_pars_[ipdf].setdefault(&#39;frac&#39;, 0.1)
            self._fix_sgn_pars_[ipdf].setdefault(&#39;frac&#39;, False)
            self._limits_sgn_pars_[ipdf].setdefault(&#39;frac&#39;, [0, 1.])
            if len(self._background_pdf_) == 0 and ipdf == len(self._signal_pdf_) - 1:
                continue
            self._fracs_[ipdf] = zfit.Parameter(f&#39;{self._name_}_frac_signal{ipdf}&#39;,
                                                self._init_sgn_pars_[ipdf][&#39;frac&#39;],
                                                self._limits_sgn_pars_[ipdf][&#39;frac&#39;][0],
                                                self._limits_sgn_pars_[ipdf][&#39;frac&#39;][1],
                                                floating=not self._fix_sgn_pars_[ipdf][&#39;frac&#39;])

            # normalisation of reflection fixed to the one of the signal
            def func_mult(params):
                return params[&#39;ros&#39;] * params[&#39;s&#39;]
            self._fracs_[ipdf + len(self._signal_pdf_)] = zfit.ComposedParameter(
                f&#39;{self._name_}_frac_refl{ipdf}&#39;,
                func_mult, params={&#39;ros&#39; : self._refl_over_sgn_[ipdf],
                                   &#39;s&#39; : self._fracs_[ipdf]}
            )

        if len(self._background_pdf_) &gt; 1:
            for ipdf, _ in enumerate(self._background_pdf_):
                self._init_bkg_pars_[ipdf].setdefault(&#39;frac&#39;, 0.1)
                self._fix_bkg_pars_[ipdf].setdefault(&#39;frac&#39;, False)
                self._limits_bkg_pars_[ipdf].setdefault(&#39;frac&#39;, [0, 1.])
                self._fracs_[ipdf + 2 * len(self._signal_pdf_)] = zfit.Parameter(
                    f&#39;{self._name_}_frac_bkg{ipdf}&#39;,
                    self._init_bkg_pars_[ipdf][&#39;frac&#39;],
                    self._limits_bkg_pars_[ipdf][&#39;frac&#39;][0],
                    self._limits_bkg_pars_[ipdf][&#39;frac&#39;][1],
                    floating=not self._fix_bkg_pars_[ipdf][&#39;frac&#39;])

        self._total_pdf_ = zfit.pdf.SumPDF(self._signal_pdf_+self._refl_pdf_+self._background_pdf_, self._fracs_)

    def __build_total_pdf_binned(self):
        &#34;&#34;&#34;
        Helper function to compose the total pdf binned from unbinned
        &#34;&#34;&#34;

        # for binned data, obs already contains the wanted binning
        if self._data_handler_.get_is_binned():
            obs = self._data_handler_.get_obs()
        # for unbinned data, one needs to impose a binning
        else:
            obs = self._data_handler_.get_binned_obs_from_unbinned_data()

        self._total_pdf_binned_ = zfit.pdf.BinnedFromUnbinnedPDF(self._total_pdf_, obs)

    def __prefit(self):
        &#34;&#34;&#34;
        Helper function to perform a prefit to the sidebands
        &#34;&#34;&#34;
        # pylint: disable=fixme
        #TODO: implement me
        Logger(&#39;Prefit step to be implemented&#39;, &#39;WARNING&#39;)

    def __get_all_fracs(self):
        &#34;&#34;&#34;
        Helper function to get all fractions

        Returns
        -------------------------------------------------
        signal_fracs: list
            fractions of the signal pdfs
        background_fracs: list
            fractions of the background pdfs
        refl_fracs: list
            fractions of the reflected signal pdfs
        signal_err_fracs: list
            errors of fractions of the signal pdfs
        bkg_err_fracs: list
            errors of fractions of the background pdfs
        refl_err_fracs: list
            errors of fractions of the reflected signal pdfs
        &#34;&#34;&#34;
        signal_fracs, bkg_fracs, refl_fracs, signal_err_fracs, bkg_err_fracs, refl_err_fracs = ([] for _ in range(6))
        for frac_par in self._fracs_:
            if frac_par is None:
                continue
            par_name = frac_par.name
            if f&#39;{self._name_}_frac_signal&#39; in par_name:
                signal_fracs.append(self._fit_result_.params[par_name][&#39;value&#39;])
                signal_err_fracs.append(self._fit_result_.params[par_name][&#39;hesse&#39;][&#39;error&#39;])
                isgn = int(par_name.split(sep=f&#39;{self._name_}_frac_signal&#39;)[-1])
                refl_fracs.append(signal_fracs[-1] * self._refl_over_sgn_[isgn])
                refl_err_fracs.append(signal_err_fracs[-1] * self._refl_over_sgn_[isgn])
            elif f&#39;{self._name_}_frac_bkg&#39; in par_name:
                bkg_fracs.append(self._fit_result_.params[par_name][&#39;value&#39;])
                bkg_err_fracs.append(self._fit_result_.params[par_name][&#39;hesse&#39;][&#39;error&#39;])

        if len(signal_fracs) == len(bkg_fracs) == len(refl_fracs) == 0:
            signal_fracs.append(1.)
            signal_err_fracs.append(0.)

        return signal_fracs, bkg_fracs, refl_fracs, signal_err_fracs, bkg_err_fracs, refl_err_fracs

    def mass_zfit(self):
        &#34;&#34;&#34;
        Perform a mass fit with the zfit library

        Returns
        -------------------------------------------------
        fit_result: zfit.minimizers.fitresult.FitResult
            The fit result
        &#34;&#34;&#34;

        if self._data_handler_ is None:
            Logger(&#39;Data handler not specified&#39;, &#39;FATAL&#39;)

        self.__build_total_pdf()
        self.__build_total_pdf_binned()
        # pylint: disable=fixme
        self.__prefit() #TODO: implement me

        if self._data_handler_.get_is_binned():
            # chi2 loss
            if self._chi2_loss_:
                loss = zfit.loss.BinnedChi2(self._total_pdf_binned_, self._data_handler_.get_binned_data())
            # nll loss
            else:
                loss = zfit.loss.BinnedNLL(self._total_pdf_binned_, self._data_handler_.get_binned_data())
        else:
            loss = zfit.loss.UnbinnedNLL(model=self._total_pdf_, data=self._data_handler_.get_data())

        self._fit_result_ = self._minimizer_.minimize(loss=loss)
        Logger(self._fit_result_, &#39;RESULT&#39;)

        if self._fit_result_.hesse() == {}:
            if self._fit_result_.hesse(method=&#39;hesse_np&#39;) == {}:
                Logger(&#39;Impossible to compute hesse error&#39;, &#39;FATAL&#39;)

        norm = self._data_handler_.get_norm()
        if len(self._fracs_) == 0:
            self._rawyield_ = self._data_handler_.get_norm()
            self._rawyield_err_ = np.sqrt(self._rawyield_)
        else:
            for ipdf, _ in enumerate(self._signal_pdf_):
                if len(self._background_pdf_) &gt; 0 or ipdf &lt; len(self._signal_pdf_) - 1:
                    self._rawyield_[ipdf] = self._fit_result_.params[
                        f&#39;{self._name_}_frac_signal{ipdf}&#39;][&#39;value&#39;] * norm
                    self._rawyield_err_[ipdf] = self._fit_result_.params[
                        f&#39;{self._name_}_frac_signal{ipdf}&#39;][&#39;hesse&#39;][&#39;error&#39;] * norm
                else:
                    frac, frac_err = 0., 0.
                    for ipdf2 in range(len(self._signal_pdf_)-1):
                        frac += self._fit_result_.params[
                            f&#39;{self._name_}_frac_signal{ipdf2}&#39;][&#39;value&#39;]
                        frac_err += np.sqrt(self._fit_result_.params[
                            f&#39;{self._name_}_frac_signal{ipdf2}&#39;][&#39;hesse&#39;][&#39;error&#39;])
                    self._rawyield_[ipdf] = frac * norm
                    self._rawyield_err_[ipdf] = frac_err * norm

        return self._fit_result_

    # pylint: disable=too-many-statements, too-many-locals
    def plot_mass_fit(self, **kwargs):
        &#34;&#34;&#34;
        Plot the mass fit

        Parameters
        -------------------------------------------------
        **kwargs: dict
            Additional optional arguments:

            - style: str
                style to be used (see https://github.com/scikit-hep/mplhep for more details)

            - logy: bool
                log scale in y axis

            - figsize: tuple
                size of the figure

            - axis_title: str
                x-axis title

            - show_extra_info: bool
                show mu, sigma, chi2/ndf, signal, bkg, signal/bkg, significance

            - extra_info_massnsigma: float
                number of sigmas for extra info

            - extra_info_massnhwhm: float
                number of hwhms for extra info (alternative to extra_info_massnsigma)

            - extra_info_massrange: list
                mass range limits for extra info (alternative to extra_info_massnsigma)

            - extra_info_loc: list
                location of extra info (one for chi2 and one for other info)

            - num: int
                number of bins to plot pdfs converted into histograms

        Returns
        -------------------------------------------------
        fig: matplotlib.figure.Figure
            figure containing the mass fit plot
        &#34;&#34;&#34;

        style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
        logy = kwargs.get(&#39;logy&#39;, False)
        figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
        bins = self._data_handler_.get_nbins()
        axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())
        show_extra_info = kwargs.get(&#39;show_extra_info&#39;, False)
        num = kwargs.get(&#39;num&#39;, 10000)
        mass_range = kwargs.get(&#39;extra_info_massrange&#39;, None)
        nhwhm = kwargs.get(&#39;extra_info_massnhwhm&#39;, None)
        nsigma = kwargs.get(&#39;extra_info_massnsigma&#39;, 3)
        loc = kwargs.get(&#39;extra_info_loc&#39;, [&#39;upper left&#39;, &#39;lower right&#39;])

        mplhep.style.use(style)

        obs = self._data_handler_.get_obs()
        limits = self._data_handler_.get_limits()

        fig, axs = plt.subplots(figsize=figsize)

        hdata = self._data_handler_.to_hist(lower_edge=limits[0],
                                            upper_edge=limits[1],
                                            nbins=bins,
                                            varname=self._data_handler_.get_var_name())

        hdata.plot(yerr=True, color=&#39;black&#39;, histtype=&#39;errorbar&#39;, label=&#39;data&#39;)
        bin_sigma = (limits[1] - limits[0]) / bins
        norm = self._data_handler_.get_norm() * bin_sigma

        x_plot = np.linspace(limits[0], limits[1], num=num)
        total_func = zfit.run(self._total_pdf_.pdf(x_plot, norm_range=obs))
        signal_funcs, refl_funcs, bkg_funcs = ([] for _ in range(3))
        for signal_pdf in self._signal_pdf_:
            signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
        for refl_pdf in self._refl_pdf_:
            refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))
        for bkg_pdf in self._background_pdf_:
            bkg_funcs.append(zfit.run(bkg_pdf.pdf(x_plot, norm_range=obs)))

        signal_fracs, bkg_fracs, refl_fracs, _, _, _ = self.__get_all_fracs()

        # first draw backgrounds
        for ibkg, bkg_func in enumerate(bkg_funcs):
            if ibkg &lt; len(bkg_fracs) - 1:
                plt.plot(x_plot, bkg_func * norm * bkg_fracs[ibkg], color=self._bkg_cmap_(ibkg),
                         ls=&#39;--&#39;, label=f&#39;background {ibkg}&#39;)
            else:
                plt.plot(x_plot, bkg_func * norm * (1-sum(bkg_fracs)-sum(signal_fracs)-sum(refl_fracs)),
                         color=&#39;firebrick&#39;, ls=&#39;--&#39;, label=f&#39;background {ibkg}&#39;)
        # then draw signals
        for isgn, (signal_func, frac) in enumerate(zip(signal_funcs, signal_fracs)):
            plt.plot(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn))
            plt.fill_between(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn),
                             alpha=0.5, label=f&#39;signal {isgn}&#39;)

        # finally draw reflected signals (if any)
        for irefl, (refl_func, frac) in enumerate(zip(refl_funcs, refl_fracs)):
            if self._name_refl_pdf_[irefl] is None:
                continue
            plt.plot(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl))
            plt.fill_between(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl),
                             alpha=0.5, label=f&#39;reflected signal {irefl}&#39;)

        plt.plot(x_plot, total_func * norm, color=&#39;xkcd:blue&#39;, label=&#39;total fit&#39;)
        plt.xlim(limits[0], limits[1])
        plt.xlabel(axis_title)
        plt.ylabel(rf&#39;counts / {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#39;)
        plt.legend(loc=&#39;best&#39;)
        if logy:
            plt.yscale(&#39;log&#39;)
            plt.ylim(min(total_func) * norm / 5, max(total_func) * norm * 5)

        if show_extra_info:
            # info on chi2/ndf
            chi2 = self.get_chi2()
            ndf = self.get_ndf()
            anchored_text_chi2 = AnchoredText(fr&#39;$\chi^2 / \mathrm{{ndf}} =${chi2:.2f} / {ndf}&#39;,
                                              loc = loc[0],
                                              frameon=False)
            # signal and background info for all signals
            text = []
            for idx, _ in enumerate(self._name_signal_pdf_):
                mass, mass_unc = self.get_mass(idx)
                sigma, sigma_unc = None, None
                gamma, gamma_unc = None, None
                if self._name_signal_pdf_[idx] in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;voigtian&#39;, &#39;hist&#39;]:
                    sigma, sigma_unc = self.get_sigma(idx)
                if self._name_signal_pdf_[idx] in [&#39;cauchy&#39;, &#39;voigtian&#39;]:
                    gamma, gamma_unc = self.get_signal_parameter(idx, &#39;gamma&#39;)
                extra_info = fr&#39;signal{idx}&#39;&#39;\n&#39; + fr&#39;  $\mu = {mass*1000:.1f}\pm{mass_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
                if sigma is not None:
                    extra_info += fr&#39;  $\sigma = {sigma*1000:.1f}\pm{sigma_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
                if gamma is not None:
                    extra_info += fr&#39;  $\Gamma = {gamma*1000:.1f}\pm{gamma_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
                if mass_range is not None:
                    signal, signal_err = self.get_signal(idx=idx, min=mass_range[0], max=mass_range[1])
                    bkg, bkg_err = self.get_background(idx=idx, min=mass_range[0], max=mass_range[1])
                    s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, min=mass_range[0],
                                                                             max=mass_range[1])
                    signif, signif_err = self.get_significance(idx=idx, min=mass_range[0],
                                                                           max=mass_range[1])
                    interval = f&#39;[{mass_range[0]:.3f}, {mass_range[1]:.3f}]&#39;
                    extra_info += fr&#39;  $S({interval})={signal:.0f} \pm {signal_err:.0f}$&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $B({interval})={bkg:.0f} \pm {bkg_err:.0f}$&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $S/B({interval})={s_over_b:.2f} \pm {s_over_b_err:.2f}$&#39;&#39;\n&#39;
                    extra_info += fr&#39;  Signif.$({interval})={signif:.1f} \pm {signif_err:.1f}$&#39;
                elif nhwhm is not None:
                    signal, signal_err = self.get_signal(idx=idx, nhwhm=nhwhm)
                    bkg, bkg_err = self.get_background(idx=idx, nhwhm=nhwhm)
                    s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, nhwhm=nhwhm)
                    signif, signif_err = self.get_significance(idx=idx, nhwhm=nhwhm)
                    extra_info += fr&#39;  $S=${signal:.0f} $\pm$ {signal_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $B({nhwhm}~\mathrm{{HWHM}})=${bkg:.0f} $\pm$ {bkg_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $S/B({nhwhm}~\mathrm{{HWHM}})=${s_over_b:.2f} $\pm$ {s_over_b_err:.2f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  Signif.$({nhwhm}~\mathrm{{HWHM}})=${signif:.1f} $\pm$ {signif_err:.1f}&#39;
                else:
                    signal, signal_err = self.get_signal(idx=idx, nsigma=nsigma)
                    bkg, bkg_err = self.get_background(idx=idx, nsigma=nsigma)
                    s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, nsigma=nsigma)
                    signif, signif_err = self.get_significance(idx=idx, nsigma=nsigma)
                    extra_info += fr&#39;  $S=${signal:.0f} $\pm$ {signal_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $B({nsigma}\sigma)=${bkg:.0f} $\pm$ {bkg_err:.0f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  $S/B({nsigma}\sigma)=${s_over_b:.2f} $\pm$ {s_over_b_err:.2f}&#39;&#39;\n&#39;
                    extra_info += fr&#39;  Signif.$({nsigma}\sigma)=${signif:.1f} $\pm$ {signif_err:.1f}&#39;
                text.append(extra_info)
            concatenated_text = &#39;\n&#39;.join(text)
            anchored_text_signal = AnchoredText(concatenated_text, loc = loc[1], frameon=False)

            axs.add_artist(anchored_text_chi2)
            axs.add_artist(anchored_text_signal)

        return fig

    # pylint: disable=too-many-statements, too-many-locals
    def dump_to_root(self, filename, **kwargs):
        &#34;&#34;&#34;
        Plot the mass fit

        Parameters
        -------------------------------------------------
        filename: str
            Name of output ROOT file

        **kwargs: dict
            Additional optional arguments:

            - axis_title: str
                x-axis title

            - num: int
                number of bins to plot pdfs converted into histograms

            - option: str
                option (recreate or update)


            - suffix: str
                suffix to append to objects
        &#34;&#34;&#34;

        num = kwargs.get(&#39;num&#39;, 10000)
        suffix = kwargs.get(&#39;suffix&#39;, &#39;&#39;)
        option = kwargs.get(&#39;option&#39;, &#39;recreate&#39;)
        bins = self._data_handler_.get_nbins()
        obs = self._data_handler_.get_obs()
        limits = self._data_handler_.get_limits()

        hdata = self._data_handler_.to_hist(lower_edge=limits[0],
                                            upper_edge=limits[1],
                                            nbins=bins,
                                            varname=self._data_handler_.get_var_name())
        # write data
        self.__write_data(hdata, f&#39;hdata{suffix}&#39;, filename, option)

        bin_sigma = (limits[1] - limits[0]) / bins
        norm = self._data_handler_.get_norm() * bin_sigma
        x_plot = np.linspace(limits[0], limits[1], num=num)

        total_func = zfit.run(self._total_pdf_.pdf(x_plot, norm_range=obs))
        # write total_func
        self.__write_pdf(histname=f&#39;total_func{suffix}&#39;, weight=total_func * norm, num=num,
                         filename=filename, option=&#39;update&#39;)

        signal_funcs, bkg_funcs, refl_funcs = ([] for _ in range(3))
        for signal_pdf in self._signal_pdf_:
            signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
        for refl_pdf in self._refl_pdf_:
            refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))
        for bkg_pdf in self._background_pdf_:
            bkg_funcs.append(zfit.run(bkg_pdf.pdf(x_plot, norm_range=obs)))

        signal_fracs, bkg_fracs, refl_fracs, _, _, _ = self.__get_all_fracs()

        # first write backgrounds
        for ibkg, bkg_func in enumerate(bkg_funcs):
            if ibkg &lt; len(bkg_fracs) - 1:
                self.__write_pdf(histname=f&#39;bkg_{ibkg}{suffix}&#39;,
                                 weight=bkg_func * norm * bkg_fracs[ibkg],
                                 num=num, filename=filename, option=&#39;update&#39;)
            else:
                self.__write_pdf(histname=f&#39;bkg_{ibkg}{suffix}&#39;,
                               weight=bkg_func * norm * (1-sum(bkg_fracs)-sum(signal_fracs)-sum(refl_fracs)),
                               num=num, filename=filename, option=&#39;update&#39;)
        # then write signals
        for isgn, (frac, signal_func) in enumerate(zip(signal_funcs, signal_fracs)):
            self.__write_pdf(histname=f&#39;signal_{isgn}{suffix}&#39;,
                           weight=signal_func * norm * frac,
                           num=num, filename=filename, option=&#39;update&#39;)

        # finally write reflected signals
        for irefl, (frac, refl_func) in enumerate(zip(refl_funcs, refl_fracs)):
            if self._name_refl_pdf_[irefl] is None:
                continue
            self.__write_pdf(histname=f&#39;refl_{irefl}{suffix}&#39;,
                           weight=refl_func * norm * frac,
                           num=num, filename=filename, option=&#39;update&#39;)

    @property
    def get_fit_result(self):
        &#34;&#34;&#34;
        Get the fit result

        Returns
        -------------------------------------------------
        fit_result: zfit.minimizers.fitresult.FitResult
            The fit result
        &#34;&#34;&#34;
        return self._fit_result_

    def get_ndf(self):
        &#34;&#34;&#34;
        Get the number of degrees of freedom for chi2 fit
        ndf = nbins - nfreeparams - 1
        -1 because the data sample size is fixed

        Returns
        -------------------------------------------------
        ndf: int
            The number of degrees of freedom
        &#34;&#34;&#34;
        nbins = self._data_handler_.get_nbins()
        nfreeparams =  len(self._fit_result_.params)
        self._ndf_ = nbins - nfreeparams - 1
        return self._ndf_

    def get_chi2(self):
        &#34;&#34;&#34;
        Get chi2 for binned data

        Returns
        -------------------------------------------------
        chi2: float
            chi2
        &#34;&#34;&#34;

        chi2 = 0
        norm = self._data_handler_.get_norm()
        if self._data_handler_.get_is_binned():
            # for chi2 loss, just retrieve loss value in fit result
            if self._chi2_loss_:
                return float(self._fit_result_.loss.value())

            # for nll loss, compute chi2 &#34;by hand&#34;
            # access normalized data values and errors for all bins
            binned_data = self._data_handler_.get_binned_data()
            data_values = binned_data.values()
            data_variances = binned_data.variances()
            # access model predicted values
            model_values = self._total_pdf_binned_.values()*norm
            # compute chi2
            for (data, model, data_variance) in zip(data_values, model_values, data_variances):
                chi2 += (data - model)**2/data_variance
            return chi2

        # for unbinned data
        data_values = self._data_handler_.get_binned_data_from_unbinned_data()
        # access model predicted values
        model_values = self._total_pdf_binned_.values()*norm
        # compute chi2
        for (data, model) in zip(data_values, model_values):
            chi2 += (data - model)**2/data

        return float(chi2)

    def get_chi2_ndf(self):
        &#34;&#34;&#34;
        Get the reduced chi2 (chi2 divided by number of degrees of freedom)
        for binned data

        Returns
        -------------------------------------------------
        chi2_ndf: float
            The reduced chi2
        &#34;&#34;&#34;
        return self.get_chi2()/self.get_ndf()

    def get_raw_residuals(self):
        &#34;&#34;&#34;
        Get the raw residuals (data_value - bkg_model_value) for all bins

        Returns
        -------------------------------------------------
        residuals: array[float]
            The residuals
        &#34;&#34;&#34;

        bins = self._data_handler_.get_nbins()
        norm = self._data_handler_.get_norm()
        residuals = [None]*bins
        background_pdf_binned_ = [None for _ in enumerate(self._name_background_pdf_)]
        model_bkg_values = [None for _ in enumerate(self._name_background_pdf_)]

        # access normalized data values and errors for all bins
        if self._data_handler_.get_is_binned():
            binned_data = self._data_handler_.get_binned_data()
            data_values = binned_data.values()
            variances = binned_data.variances()
            obs = self._data_handler_.get_obs()
        else:
            data_values = self._data_handler_.get_binned_data_from_unbinned_data()
            variances = data_values # poissonian errors
            obs = self._data_handler_.get_binned_obs_from_unbinned_data()

        # get background fractions
        if len(self._background_pdf_) == 1:
            signal_fracs, _, refl_fracs, _, _, _ = self.__get_all_fracs()
            bkg_fracs = [1 - sum(signal_fracs) - sum(refl_fracs)]
        else:
            _, bkg_fracs, _, _, _, _ = self.__get_all_fracs()
        # access model predicted values for background
        for ipdf, _ in enumerate(self._name_background_pdf_):
            background_pdf_binned_[ipdf] = zfit.pdf.BinnedFromUnbinnedPDF(self._background_pdf_[ipdf], obs)
            model_bkg_values[ipdf] = background_pdf_binned_[ipdf].values()*bkg_fracs[ipdf]*norm
        # compute residuals
        for ibin, data in enumerate(data_values):
            residuals[ibin] = float(data)
            for ipdf, _ in enumerate(self._name_background_pdf_):
                residuals[ibin] -= model_bkg_values[ipdf][ibin]

        return residuals, variances

    def plot_raw_residuals(self, **kwargs):
        &#34;&#34;&#34;
        Plot the raw residuals

        Parameters
        -------------------------------------------------
        **kwargs: dict
            Additional optional arguments:

            - style: str
                style to be used (see https://github.com/scikit-hep/mplhep for more details)

            - figsize: tuple
                size of the figure

            - axis_title: str
                x-axis title

        Returns
        -------------------------------------------------
        fig: matplotlib.figure.Figure
            figure containing the raw residuals plot
        &#34;&#34;&#34;

        style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
        figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
        axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())

        mplhep.style.use(style)

        obs = self._data_handler_.get_obs()
        limits = self._data_handler_.get_limits()

        fig = plt.figure(figsize=figsize)

        residuals, variances = self.get_raw_residuals()
        # draw residuals
        plt.errorbar(
            self._data_handler_.get_bin_center(),
            residuals,
            xerr = None,
            yerr = np.sqrt(variances),
            linestyle = &#34;None&#34;,
            elinewidth = 1,
            capsize = 0,
            color = &#34;black&#34;,
            marker = &#34;o&#34;,
            markersize = 5,
            label = &#34;residuals&#34;
        )
        bins = self._data_handler_.get_nbins()
        bin_sigma = (limits[1] - limits[0]) / bins
        norm = self._data_handler_.get_norm() * bin_sigma

        x_plot = np.linspace(limits[0], limits[1], num=1000)
        signal_funcs, refl_funcs = ([] for _ in range(2))
        for signal_pdf in self._signal_pdf_:
            signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
        for refl_pdf in self._refl_pdf_:
            refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))

        signal_fracs, _, refl_fracs, _, _, _ = self.__get_all_fracs()

        # draw signals
        for isgn, (signal_func, frac) in enumerate(zip(signal_funcs, signal_fracs)):
            plt.plot(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn))
            plt.fill_between(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn),
                             alpha=0.5, label=f&#39;signal {isgn}&#39;)

        # finally draw reflected signals (if any)
        is_there_refl = False
        for irefl, (refl_func, frac) in enumerate(zip(refl_funcs, refl_fracs)):
            if self._name_refl_pdf_[irefl] is None:
                continue
            is_there_refl = True
            plt.plot(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl))
            plt.fill_between(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl),
                             alpha=0.5, label=f&#39;reflected signal {irefl}&#39;)

        # draw signal + reflected signals (if any)
        if is_there_refl:
            for isgn, (signal_func, refl_func, frac_sgn, frac_refl) in enumerate(
                zip(signal_funcs, refl_funcs, signal_fracs, refl_fracs)):
                plt.plot(x_plot, (signal_func * frac_sgn + frac_refl * refl_func) * norm,
                        color=&#39;xkcd:blue&#39;, label=&#39;total - bkg&#39;)


        plt.xlim(limits[0], limits[1])
        plt.xlabel(axis_title)
        plt.ylabel(rf&#39;(data - fitted bkg) / {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#39;)
        plt.legend(loc=&#39;best&#39;)

        return fig

    def get_std_residuals(self):
        &#34;&#34;&#34;
        Get the standardized residuals
        (data_value - bkg_model_value)/ sigma_data for all bins

        Returns
        -------------------------------------------------
        residuals: array[float]
            The standardized residuals
        &#34;&#34;&#34;

        bins = self._data_handler_.get_nbins()
        norm = self._data_handler_.get_norm()
        residuals, residuals_variances = [None]*bins, [None]*bins

        # access normalized data values and errors for all bins
        if self._data_handler_.get_is_binned():
            binned_data = self._data_handler_.get_binned_data()
            data_values = binned_data.values()
            variances = binned_data.variances()
        else:
            data_values = self._data_handler_.get_binned_data_from_unbinned_data()
            variances = data_values # poissonian errors

        # access model predicted values for background
        self.__build_total_pdf_binned()
        model_values = self._total_pdf_binned_.values()*norm
        for ibin, (data, model, variance) in enumerate(zip(data_values, model_values, variances)):
            if variance == 0:
                Logger(&#39;Null variance. Consider enlarging the bins.&#39;, &#39;FATAL&#39;)
            residuals[ibin] = float((data - model)/np.sqrt(variance))
            residuals_variances[ibin] = float(variance/np.sqrt(variance))

        return residuals, residuals_variances

    def plot_std_residuals(self, **kwargs):
        &#34;&#34;&#34;
        Plot the raw residuals

        Parameters
        -------------------------------------------------
        **kwargs: dict
            Additional optional arguments:

            - style: str
                style to be used (see https://github.com/scikit-hep/mplhep for more details)

            - figsize: tuple
                size of the figure

            - axis_title: str
                x-axis title

        Returns
        -------------------------------------------------
        fig: matplotlib.figure.Figure
            figure containing the raw residuals plot
        &#34;&#34;&#34;

        style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
        figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
        axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())

        mplhep.style.use(style)

        limits = self._data_handler_.get_limits()
        bins = self._data_handler_.get_nbins()
        bin_center = self._data_handler_.get_bin_center()

        fig = plt.figure(figsize=figsize)

        residuals, variances = self.get_std_residuals()
        # draw residuals
        plt.errorbar(bin_center,
                    residuals,
                    xerr = None,
                    yerr = np.sqrt(variances),
                    linestyle = &#34;None&#34;,
                    elinewidth = 1,
                    capsize = 0,
                    color = &#34;black&#34;,
                    marker = &#34;o&#34;,
                    markersize = 5,
                    label = None)

        # line at 0
        plt.plot([bin_center[0], bin_center[-1]], [0., 0.], lw=2, color=&#39;xkcd:blue&#39;)
        # line at -3 sigma
        plt.plot([bin_center[0], bin_center[-1]], [-3., -3.], lw=2, color=&#39;xkcd:red&#39;)
        # line at 3 sigma
        plt.plot([bin_center[0], bin_center[-1]], [3., 3.], lw=2, color=&#39;xkcd:red&#39;)

        plt.xlim(limits[0], limits[1])
        plt.xlabel(axis_title)
        plt.ylabel(fr&#34;$\dfrac{{ \mathrm{{data}} - \mathrm{{total \ fit}} }}{{ \sigma_{{ \mathrm{{data}} }} }}$&#34;
                   fr&#34;/ {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#34;)

        return fig

    def get_raw_yield(self, idx=0):
        &#34;&#34;&#34;
        Get the raw yield and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the raw yield to be returned (default: 0)

        Returns
        -------------------------------------------------
        raw_yield: float
            The raw yield obtained from the fit
        raw_yield_err: float
            The raw yield error obtained from the fit
        &#34;&#34;&#34;
        return self._rawyield_[idx], self._rawyield_err_[idx]

    def get_mass(self, idx=0):
        &#34;&#34;&#34;
        Get the mass and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the mass to be returned (default: 0)

        Returns
        -------------------------------------------------
        mass: float
            The mass value obtained from the fit
        mass_err: float
            The mass error obtained from the fit
        &#34;&#34;&#34;
        if &#39;hist&#39; in self._name_signal_pdf_[idx]:
            hist = self._signal_pdf_[idx].to_hist()
            bin_limits = hist.to_numpy()[1]
            centres = [0.5 * (minn + maxx) for minn, maxx in zip(bin_limits[1:],  bin_limits[:-1])]
            counts = hist.values()
            mass = np.average(centres, weights=counts)
            mass_err = 0.
        else:
            mass_name = &#39;m&#39; if self._name_signal_pdf_[idx] == &#39;cauchy&#39; else &#39;mu&#39;
            if self._fix_sgn_pars_[idx][mass_name]:
                mass = self._init_sgn_pars_[idx][mass_name]
                mass_err = 0.
            else:
                mass = self._fit_result_.params[f&#39;{self._name_}_{mass_name}_signal{idx}&#39;][&#39;value&#39;]
                mass_err = self._fit_result_.params[f&#39;{self._name_}_{mass_name}_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return mass, mass_err

    def get_sigma(self, idx=0):
        &#34;&#34;&#34;
        Get the sigma and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the sigma to be returned (default: 0)

        Returns
        -------------------------------------------------
        sigma: float
            The sigma value obtained from the fit
        sigma_err: float
            The sigma error obtained from the fit
        &#34;&#34;&#34;
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;voigtian&#39;, &#39;hist&#39;]:
            Logger(f&#39;Sigma parameter not defined for {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;ERROR&#39;)
            return 0., 0.

        # if histogram, the rms is used as proxy
        if &#39;hist&#39; in self._name_signal_pdf_[idx]:
            Logger(f&#39;RMS used as proxy for sigma parameter of {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;WARNING&#39;)
            mean = self.get_mass(idx)[0]
            hist = self._signal_pdf_[idx].to_hist()
            bin_limits = hist.to_numpy()[1]
            centres = [0.5 * (minn + maxx) for minn, maxx in zip(bin_limits[1:],  bin_limits[:-1])]
            counts = hist.values()
            sigma = np.sqrt(np.average((centres - mean)**2, weights=counts))
            sigma_err = 0.
        else:
            if self._fix_sgn_pars_[idx][&#39;sigma&#39;]:
                sigma = self._init_sgn_pars_[idx][&#39;sigma&#39;]
                sigma_err = 0.
            else:
                sigma = self._fit_result_.params[f&#39;{self._name_}_sigma_signal{idx}&#39;][&#39;value&#39;]
                sigma_err = self._fit_result_.params[f&#39;{self._name_}_sigma_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return sigma, sigma_err

    def get_hwhm(self, idx=0):
        &#34;&#34;&#34;
        Get the half width half maximum and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the sigma to be returned (default: 0)

        Returns
        -------------------------------------------------
        hwhm: float
            The sigma value obtained from the fit
        hwhm_err: float
            The sigma error obtained from the fit
        &#34;&#34;&#34;
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
            Logger(f&#39;HFWM parameter not defined for {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;ERROR&#39;)
            return 0., 0.

        if self._name_signal_pdf_[idx] == &#39;gaussian&#39;:
            mult_fact = np.sqrt(2 * np.log(2))
            hwhm, hwhm_err = self.get_sigma(idx)
            hwhm *= mult_fact
            hwhm_err *= mult_fact
        elif self._name_signal_pdf_[idx] == &#39;cauchy&#39;:
            hwhm, hwhm_err = self.get_signal_parameter(idx, &#39;gamma&#39;)
        elif self._name_signal_pdf_[idx] == &#39;voigtian&#39;:
            mult_fact = np.sqrt(2 * np.log(2))
            sigma, sigma_err = self.get_sigma(idx)
            sigma *= mult_fact
            sigma_err *= mult_fact
            gamma, gamma_err = self.get_signal_parameter(idx, &#39;gamma&#39;)
            hwhm = 0.5346 * gamma + np.sqrt(0.2166 * gamma**2 + sigma**2)
            # we neglect the correlation between sigma and gamma
            der_sigma = sigma / np.sqrt(0.0721663 + sigma**2)
            der_gamma = 0.5346 + (0.2166 * gamma) / np.sqrt(0.2166 * gamma**2 + sigma**2)
            hwhm_err = np.sqrt(der_sigma**2 * sigma_err**2 + der_gamma**2 * gamma_err**2)

        return hwhm, hwhm_err

    def get_signal_parameter(self, idx, par):
        &#34;&#34;&#34;
        Get a signal parameter and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the parameter to be returned (default: 0)
        par: str
            parameter to return

        Returns
        -------------------------------------------------
        parameter: float
            The parameter value obtained from the fit
        parameter_err: float
            The parameter error obtained from the fit

        &#34;&#34;&#34;

        if self._fix_sgn_pars_[idx][par]:
            parameter = self._init_sgn_pars_[idx][par]
            parameter_err = 0.
        else:
            parameter = self._fit_result_.params[f&#39;{self._name_}_{par}_signal{idx}&#39;][&#39;value&#39;]
            parameter_err = self._fit_result_.params[f&#39;{self._name_}_{par}_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return parameter, parameter_err

    def get_background_parameter(self, idx, par):
        &#34;&#34;&#34;
        Get a background parameter and its error

        Parameters
        -------------------------------------------------
        idx: int
            Index of the parameter to be returned (default: 0)
        par: str
            parameter to return

        Returns
        -------------------------------------------------
        parameter: float
            The parameter value obtained from the fit
        parameter_err: float
            The parameter error obtained from the fit

        &#34;&#34;&#34;

        if self._fix_bkg_pars_[idx][par]:
            parameter = self._init_bkg_pars_[idx][par]
            parameter_err = 0.
        else:
            parameter = self._fit_result_.params[f&#39;{self._name_}_{par}_bkg{idx}&#39;][&#39;value&#39;]
            parameter_err = self._fit_result_.params[f&#39;{self._name_}_{par}_bkg{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

        return parameter, parameter_err

    def get_signal(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the signal and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be returned
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for signal computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for signal computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for signal computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        signal: float
            The signal value obtained from the fit
        signal_err: float
            The signal error obtained from the fit
        &#34;&#34;&#34;

        nsigma = kwargs.get(&#39;nsigma&#39;, 3.)
        nhwhm = kwargs.get(&#39;nhwhm&#39;, None)
        min_value = kwargs.get(&#39;min&#39;, None)
        max_value = kwargs.get(&#39;max&#39;, None)
        use_nsigma = True

        if nhwhm is not None and (min_value is not None or max_value is not None):
            Logger(&#39;I cannot compute the signal within a fixed mass interval and a number of HWFM&#39;, &#39;ERROR&#39;)
            return 0., 0.

        if min_value is not None and max_value is not None:
            use_nsigma = False

        if nhwhm is not None:
            use_nsigma = False
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
                Logger(&#39;HWHM not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            hwhm, _ = self.get_hwhm(idx)
            min_value = mass - nhwhm * hwhm
            max_value = mass + nhwhm * hwhm

        if use_nsigma:
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;hist&#39;]:
                Logger(&#39;Sigma not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            sigma, _ = self.get_sigma(idx)
            min_value = mass - nsigma * sigma
            max_value = mass + nsigma * sigma

        # pylint: disable=missing-kwoa
        signal = self._signal_pdf_[idx].integrate((min_value, max_value))

        signal_fracs, refl_fracs, _, signal_err_fracs, _, _ = self.__get_all_fracs()

        if len(self._background_pdf_) &gt; 0:
            frac = signal_fracs[idx]
            frac_err = signal_err_fracs[idx]
        else:
            if len(self._signal_pdf_) == 1:
                frac = 1.
                frac_err = 0.
            if idx &lt; len(signal_fracs):
                frac = signal_fracs[idx]
                frac_err = signal_err_fracs[idx]
            else:
                frac = 1. - sum(signal_fracs) - sum(refl_fracs)
                frac_err = np.sqrt(sum(list(err**2 for err in signal_err_fracs)))

        norm = self._data_handler_.get_norm()
        norm_err = norm * frac_err
        norm *= frac

        return float(signal * norm), float(signal * norm_err)

    def get_background(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the background and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be used to compute nsigma window
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for background computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for background computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for background computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        background: float
            The background value obtained from the fit
        background_err: float
            The background error obtained from the fit
        &#34;&#34;&#34;

        if not self._background_pdf_:
            Logger(&#39;Background not fitted&#39;, &#39;ERROR&#39;)
            return 0., 0.

        nsigma = kwargs.get(&#39;nsigma&#39;, 3.)
        nhwhm = kwargs.get(&#39;nhwhm&#39;, None)
        min_value = kwargs.get(&#39;min&#39;, None)
        max_value = kwargs.get(&#39;max&#39;, None)
        use_nsigma = True

        if nhwhm is not None and (min_value is not None or max_value is not None):
            Logger(&#39;I cannot compute the signal within a fixed mass interval and a number of HWFM&#39;, &#39;ERROR&#39;)
            return 0., 0.

        if min_value is not None and max_value is not None:
            use_nsigma = False

        if nhwhm is not None:
            use_nsigma = False
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
                Logger(&#39;HWHM not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            hwhm, _ = self.get_hwhm(idx)
            min_value = mass - nhwhm * hwhm
            max_value = mass + nhwhm * hwhm

        if use_nsigma:
            if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;hist&#39;]:
                Logger(&#39;Sigma not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
                return 0., 0.
            mass, _ = self.get_mass(idx)
            sigma, _ = self.get_sigma(idx)
            min_value = mass - nsigma * sigma
            max_value = mass + nsigma * sigma

        signal_fracs, bkg_fracs, refl_fracs, signal_err_fracs, bkg_err_fracs, _ = self.__get_all_fracs()

        # pylint: disable=missing-kwoa
        background, background_err = 0., 0.
        for idx2, bkg in enumerate(self._background_pdf_):

            if idx2 == len(self._background_pdf_) - 1:
                frac = 1. - sum(signal_fracs) - sum(refl_fracs)
                frac_err = np.sqrt(sum(list(err**2 for err in signal_err_fracs)))
            else:
                frac = bkg_fracs[idx2]
                frac_err = bkg_err_fracs[idx2]

            norm = self._data_handler_.get_norm()
            norm_err = norm * frac_err
            norm *= frac

            bkg_int = bkg.integrate((min_value, max_value))
            background += bkg_int * norm
            background_err += (bkg_int * norm_err)**2

        background_err = np.sqrt(background_err)

        return float(background), float(background_err)

    def get_signal_over_background(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the S/B ratio and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be used to compute nsigma window
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for signal and background computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for signal and background computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for signal and background computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        signal_over_background: float
            The S/B value obtained from the fit
        signal_over_background_err: float
            The S/B error obtained from the fit
        &#34;&#34;&#34;

        signal = self.get_signal(idx, **kwargs)
        bkg = self.get_background(idx, **kwargs)
        signal_over_background = signal[0]/bkg[0]
        signal_over_background_err = np.sqrt(signal[1]**2/signal[0]**2 + bkg[1]**2/bkg[0]**2)
        signal_over_background_err *= signal_over_background

        return signal_over_background, signal_over_background_err

    def get_significance(self, idx=0, **kwargs):
        &#34;&#34;&#34;
        Get the significance and its error in a given invariant-mass region

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal to be used to compute nsigma window
        **kwargs: dict
            Additional optional arguments:

            - nsigma: float
                nsigma invariant-mass window around mean for signal and background computation

            - nhwhm: float
                number of hwhm invariant-mass window around mean for signal and background computation
                (alternative to nsigma)

            - min: float
                minimum value of invariant-mass for signal and background computation (alternative to nsigma)

            - max: float
                maximum value of invariant-mass for signal and background computation (alternative to nsigma)

        Returns
        -------------------------------------------------
        significance: float
            The significance value obtained from the fit
        significance_err: float
            The significance error obtained from the fit
        &#34;&#34;&#34;

        signal = self.get_signal(idx, **kwargs)
        bkg = self.get_background(idx, **kwargs)
        significance = signal[0]/np.sqrt(signal[0]+bkg[0])
        sig_plus_bkg = signal[0] + bkg[0]

        significance_err = significance*np.sqrt(
            (signal[1]**2 + bkg[1]**2) / (4. * sig_plus_bkg**2) + (
                bkg[0]/sig_plus_bkg) * signal[1]**2 / signal[0]**2)

        return significance, significance_err

    def set_particle_mass(self, idx, **kwargs):
        &#34;&#34;&#34;
        Set the particle mass

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        **kwargs: dict
            Additional optional arguments:

            - mass: float
                The mass of the particle

            - pdg_id: int
                PDG ID of the particle (alternative to mass)

            - pdg_name: str
                Name of the particle (alternative to mass)

            - limits: list
                minimum and maximum limits for the mass parameter

            - fix: bool
                fix the mass parameter
        &#34;&#34;&#34;
        mass_name = &#39;m&#39; if self._name_signal_pdf_[idx] == &#39;cauchy&#39; else &#39;mu&#39;
        mass = 0.
        if &#39;mass&#39; in kwargs:
            mass = kwargs[&#39;mass&#39;]
        elif &#39;pdg_id&#39; in kwargs:
            mass = Particle.from_pdgid(kwargs[&#39;pdg_id&#39;]).mass*1e-3
        elif &#39;pdg_name&#39; in kwargs:
            mass = Particle.from_name(kwargs[&#39;pdg_name&#39;]).mass*1e-3
        else:
            Logger(f&#39;&#34;mass&#34;, &#34;pdg_id&#34;, and &#34;pdg_name&#34; not provided, mass value for signal {idx} will not be set&#39;,
                   &#39;ERROR&#39;)
        self._init_sgn_pars_[idx][mass_name] = mass
        if &#39;limits&#39; in kwargs:
            self._limits_sgn_pars_[idx][mass_name] = kwargs[&#39;limits&#39;]
        if &#39;fix&#39; in kwargs:
            self._fix_sgn_pars_[idx][mass_name] = kwargs[&#39;fix&#39;]

    def set_signal_initpar(self, idx, par_name, init_value, **kwargs):
        &#34;&#34;&#34;
        Set a signal parameter

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        par_name: str
            The name of the parameter to be set
        init_value: float
            The value of parameter to be set
        **kwargs: dict
            Additional optional arguments:

            - limits: list
                minimum and maximum limits for the parameter

            - fix: bool
                fix the parameter to init_value
        &#34;&#34;&#34;
        self._init_sgn_pars_[idx][par_name] = init_value
        if &#39;limits&#39; in kwargs:
            self._limits_sgn_pars_[idx][par_name] = kwargs[&#39;limits&#39;]
        if &#39;fix&#39; in kwargs:
            self._fix_sgn_pars_[idx][par_name] = kwargs[&#39;fix&#39;]

    def set_background_initpar(self, idx, par_name, init_value, **kwargs):
        &#34;&#34;&#34;
        Set a background parameter

        Parameters
        -------------------------------------------------
        idx: int
            Index of the background
        par_name: str
            The name of the parameter to be set
        init_value: float
            The value of parameter to be set
        **kwargs: dict
            Additional optional arguments:

            - limits: list
                minimum and maximum limits for the parameter

            - fix: bool
                fix the mass parameter
        &#34;&#34;&#34;
        self._init_bkg_pars_[idx][par_name] = init_value
        if &#39;limits&#39; in kwargs:
            self._limits_bkg_pars_[idx][par_name] = kwargs[&#39;limits&#39;]
        if &#39;fix&#39; in kwargs:
            self._fix_bkg_pars_[idx][par_name] = kwargs[&#39;fix&#39;]

    # pylint: disable=line-too-long
    def set_signal_template(self, idx, sample):
        &#34;&#34;&#34;
        Set sample and options for signal template

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        sample: flarefly.DataHandler
            Data sample for histogram template
        &#34;&#34;&#34;

        self._hist_signal_sample_[idx] = sample

    # pylint: disable=line-too-long
    def set_signal_kde(self, idx, sample, **kwargs):
        &#34;&#34;&#34;
        Set sample and options for signal kde

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        sample: flarefly.DataHandler
            Data sample for Kernel Density Estimation
        **kwargs: dict
            Arguments for kde options. See
            https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
            for more details
        &#34;&#34;&#34;

        self._kde_signal_sample_[idx] = sample
        self._kde_signal_option_[idx] = kwargs

    # pylint: disable=line-too-long
    def set_reflection_template(self, idx, sample, r_over_s):
        &#34;&#34;&#34;
        Set sample and options for reflected signal template

        Parameters
        -------------------------------------------------
        idx: int
            Index of the reflected signal
        sample: flarefly.DataHandler
            Data sample for histogram template
        r_over_s: float
            R/S ratio
        &#34;&#34;&#34;

        self._hist_refl_sample_[idx] = sample
        self._refl_over_sgn_[idx] = r_over_s

    # pylint: disable=line-too-long
    def set_reflection_kde(self, idx, sample, r_over_s, **kwargs):
        &#34;&#34;&#34;
        Set sample and options for reflected signal kde

        Parameters
        -------------------------------------------------
        idx: int
            Index of the signal
        sample: flarefly.DataHandler
            Data sample for Kernel Density Estimation
        r_over_s: float
            R/S ratio
        **kwargs: dict
            Arguments for kde options. See
            https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
            for more details
        &#34;&#34;&#34;

        self._kde_signal_sample_[idx] = sample
        self._kde_signal_option_[idx] = kwargs
        self._refl_over_sgn_[idx] = r_over_s

    # pylint: disable=line-too-long
    def set_background_template(self, idx, sample):
        &#34;&#34;&#34;
        Set sample and options for background template histogram

        Parameters
        -------------------------------------------------
        idx: int
            Index of the background
        sample: flarefly.DataHandler
            Data sample for template histogram
        &#34;&#34;&#34;

        self._hist_bkg_sample_[idx] = sample

    # pylint: disable=line-too-long
    def set_background_kde(self, idx, sample, **kwargs):
        &#34;&#34;&#34;
        Set sample and options for background kde

        Parameters
        -------------------------------------------------
        idx: int
            Index of the background
        sample: flarefly.DataHandler
            Data sample for Kernel Density Estimation
        **kwargs: dict
            Arguments for kde options. See
            https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
            for more details
        &#34;&#34;&#34;

        self._kde_bkg_sample_[idx] = sample
        self._kde_bkg_option_[idx] = kwargs

    def __write_data(self, hdata, histname=&#39;hdata&#39;, filename=&#39;output.root&#39;, option=&#39;recreate&#39;):
        &#34;&#34;&#34;
        Helper method to save a data histogram in a .root file (TH1D format)

        Parameters
        -------------------------------------------------
        hdata: hist
            Histogram containing the data

        histname: str
            Name of the histogram

        filename: str
            Name of the ROOT file

        option: str
            Option (recreate or update)
        &#34;&#34;&#34;
        if option not in [&#39;recreate&#39;, &#39;update&#39;]:
            Logger(&#39;Illegal option to save outputs in ROOT file!&#39;, &#39;FATAL&#39;)

        if option == &#39;recreate&#39;:
            with uproot.recreate(filename) as ofile:
                ofile[histname] = hdata
        else:
            with uproot.update(filename) as ofile:
                ofile[histname] = hdata

    def __write_pdf(self, histname, weight, num, filename=&#39;output.root&#39;, option=&#39;recreate&#39;):
        &#34;&#34;&#34;
        Helper method to save a pdf histogram in a .root file (TH1D format)

        Parameters
        -------------------------------------------------
        histname: str
            Name of the histogram

        weight: array[float]
            Array of weights for histogram bins

        num: int
            Number of bins to plot pdfs converted into histograms

        filename: str
            ROOT file name

        option: str
            Option (recreate or update)
        &#34;&#34;&#34;

        if option not in [&#39;recreate&#39;, &#39;update&#39;]:
            Logger(&#39;Illegal option to save outputs in ROOT file!&#39;, &#39;FATAL&#39;)

        limits = self._data_handler_.get_limits()
        x_plot = np.linspace(limits[0], limits[1], num=num)
        histo = Hist.new.Reg(num, limits[0], limits[1], name=self._data_handler_.get_var_name()).Double()
        histo.fill(x_plot, weight=weight)

        if option == &#39;recreate&#39;:
            with uproot.recreate(filename) as ofile:
                ofile[histname] = histo
        else:
            with uproot.update(filename) as ofile:
                ofile[histname] = histo</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="flarefly.fitter.F2MassFitter.get_fit_result"><code class="name">var <span class="ident">get_fit_result</span></code></dt>
<dd>
<div class="desc"><p>Get the fit result</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fit_result</code></strong> :&ensp;<code>zfit.minimizers.fitresult.FitResult</code></dt>
<dd>The fit result</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def get_fit_result(self):
    &#34;&#34;&#34;
    Get the fit result

    Returns
    -------------------------------------------------
    fit_result: zfit.minimizers.fitresult.FitResult
        The fit result
    &#34;&#34;&#34;
    return self._fit_result_</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="flarefly.fitter.F2MassFitter.dump_to_root"><code class="name flex">
<span>def <span class="ident">dump_to_root</span></span>(<span>self, filename, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the mass fit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of output ROOT file</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>axis_title: str
x-axis title</p>
</li>
<li>
<p>num: int
number of bins to plot pdfs converted into histograms</p>
</li>
<li>
<p>option: str
option (recreate or update)</p>
</li>
<li>
<p>suffix: str
suffix to append to objects</p>
</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_to_root(self, filename, **kwargs):
    &#34;&#34;&#34;
    Plot the mass fit

    Parameters
    -------------------------------------------------
    filename: str
        Name of output ROOT file

    **kwargs: dict
        Additional optional arguments:

        - axis_title: str
            x-axis title

        - num: int
            number of bins to plot pdfs converted into histograms

        - option: str
            option (recreate or update)


        - suffix: str
            suffix to append to objects
    &#34;&#34;&#34;

    num = kwargs.get(&#39;num&#39;, 10000)
    suffix = kwargs.get(&#39;suffix&#39;, &#39;&#39;)
    option = kwargs.get(&#39;option&#39;, &#39;recreate&#39;)
    bins = self._data_handler_.get_nbins()
    obs = self._data_handler_.get_obs()
    limits = self._data_handler_.get_limits()

    hdata = self._data_handler_.to_hist(lower_edge=limits[0],
                                        upper_edge=limits[1],
                                        nbins=bins,
                                        varname=self._data_handler_.get_var_name())
    # write data
    self.__write_data(hdata, f&#39;hdata{suffix}&#39;, filename, option)

    bin_sigma = (limits[1] - limits[0]) / bins
    norm = self._data_handler_.get_norm() * bin_sigma
    x_plot = np.linspace(limits[0], limits[1], num=num)

    total_func = zfit.run(self._total_pdf_.pdf(x_plot, norm_range=obs))
    # write total_func
    self.__write_pdf(histname=f&#39;total_func{suffix}&#39;, weight=total_func * norm, num=num,
                     filename=filename, option=&#39;update&#39;)

    signal_funcs, bkg_funcs, refl_funcs = ([] for _ in range(3))
    for signal_pdf in self._signal_pdf_:
        signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
    for refl_pdf in self._refl_pdf_:
        refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))
    for bkg_pdf in self._background_pdf_:
        bkg_funcs.append(zfit.run(bkg_pdf.pdf(x_plot, norm_range=obs)))

    signal_fracs, bkg_fracs, refl_fracs, _, _, _ = self.__get_all_fracs()

    # first write backgrounds
    for ibkg, bkg_func in enumerate(bkg_funcs):
        if ibkg &lt; len(bkg_fracs) - 1:
            self.__write_pdf(histname=f&#39;bkg_{ibkg}{suffix}&#39;,
                             weight=bkg_func * norm * bkg_fracs[ibkg],
                             num=num, filename=filename, option=&#39;update&#39;)
        else:
            self.__write_pdf(histname=f&#39;bkg_{ibkg}{suffix}&#39;,
                           weight=bkg_func * norm * (1-sum(bkg_fracs)-sum(signal_fracs)-sum(refl_fracs)),
                           num=num, filename=filename, option=&#39;update&#39;)
    # then write signals
    for isgn, (frac, signal_func) in enumerate(zip(signal_funcs, signal_fracs)):
        self.__write_pdf(histname=f&#39;signal_{isgn}{suffix}&#39;,
                       weight=signal_func * norm * frac,
                       num=num, filename=filename, option=&#39;update&#39;)

    # finally write reflected signals
    for irefl, (frac, refl_func) in enumerate(zip(refl_funcs, refl_fracs)):
        if self._name_refl_pdf_[irefl] is None:
            continue
        self.__write_pdf(histname=f&#39;refl_{irefl}{suffix}&#39;,
                       weight=refl_func * norm * frac,
                       num=num, filename=filename, option=&#39;update&#39;)</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_background"><code class="name flex">
<span>def <span class="ident">get_background</span></span>(<span>self, idx=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the background and its error in a given invariant-mass region</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal to be used to compute nsigma window</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>nsigma: float
nsigma invariant-mass window around mean for background computation</p>
</li>
<li>
<p>nhwhm: float
number of hwhm invariant-mass window around mean for signal and background computation
(alternative to nsigma)</p>
</li>
<li>
<p>min: float
minimum value of invariant-mass for background computation (alternative to nsigma)</p>
</li>
<li>
<p>max: float
maximum value of invariant-mass for background computation (alternative to nsigma)</p>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>background</code></strong> :&ensp;<code>float</code></dt>
<dd>The background value obtained from the fit</dd>
<dt><strong><code>background_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The background error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_background(self, idx=0, **kwargs):
    &#34;&#34;&#34;
    Get the background and its error in a given invariant-mass region

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal to be used to compute nsigma window
    **kwargs: dict
        Additional optional arguments:

        - nsigma: float
            nsigma invariant-mass window around mean for background computation

        - nhwhm: float
            number of hwhm invariant-mass window around mean for signal and background computation
            (alternative to nsigma)

        - min: float
            minimum value of invariant-mass for background computation (alternative to nsigma)

        - max: float
            maximum value of invariant-mass for background computation (alternative to nsigma)

    Returns
    -------------------------------------------------
    background: float
        The background value obtained from the fit
    background_err: float
        The background error obtained from the fit
    &#34;&#34;&#34;

    if not self._background_pdf_:
        Logger(&#39;Background not fitted&#39;, &#39;ERROR&#39;)
        return 0., 0.

    nsigma = kwargs.get(&#39;nsigma&#39;, 3.)
    nhwhm = kwargs.get(&#39;nhwhm&#39;, None)
    min_value = kwargs.get(&#39;min&#39;, None)
    max_value = kwargs.get(&#39;max&#39;, None)
    use_nsigma = True

    if nhwhm is not None and (min_value is not None or max_value is not None):
        Logger(&#39;I cannot compute the signal within a fixed mass interval and a number of HWFM&#39;, &#39;ERROR&#39;)
        return 0., 0.

    if min_value is not None and max_value is not None:
        use_nsigma = False

    if nhwhm is not None:
        use_nsigma = False
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
            Logger(&#39;HWHM not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
            return 0., 0.
        mass, _ = self.get_mass(idx)
        hwhm, _ = self.get_hwhm(idx)
        min_value = mass - nhwhm * hwhm
        max_value = mass + nhwhm * hwhm

    if use_nsigma:
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;hist&#39;]:
            Logger(&#39;Sigma not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
            return 0., 0.
        mass, _ = self.get_mass(idx)
        sigma, _ = self.get_sigma(idx)
        min_value = mass - nsigma * sigma
        max_value = mass + nsigma * sigma

    signal_fracs, bkg_fracs, refl_fracs, signal_err_fracs, bkg_err_fracs, _ = self.__get_all_fracs()

    # pylint: disable=missing-kwoa
    background, background_err = 0., 0.
    for idx2, bkg in enumerate(self._background_pdf_):

        if idx2 == len(self._background_pdf_) - 1:
            frac = 1. - sum(signal_fracs) - sum(refl_fracs)
            frac_err = np.sqrt(sum(list(err**2 for err in signal_err_fracs)))
        else:
            frac = bkg_fracs[idx2]
            frac_err = bkg_err_fracs[idx2]

        norm = self._data_handler_.get_norm()
        norm_err = norm * frac_err
        norm *= frac

        bkg_int = bkg.integrate((min_value, max_value))
        background += bkg_int * norm
        background_err += (bkg_int * norm_err)**2

    background_err = np.sqrt(background_err)

    return float(background), float(background_err)</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_background_parameter"><code class="name flex">
<span>def <span class="ident">get_background_parameter</span></span>(<span>self, idx, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a background parameter and its error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the parameter to be returned (default: 0)</dd>
<dt><strong><code>par</code></strong> :&ensp;<code>str</code></dt>
<dd>parameter to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code>float</code></dt>
<dd>The parameter value obtained from the fit</dd>
<dt><strong><code>parameter_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The parameter error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_background_parameter(self, idx, par):
    &#34;&#34;&#34;
    Get a background parameter and its error

    Parameters
    -------------------------------------------------
    idx: int
        Index of the parameter to be returned (default: 0)
    par: str
        parameter to return

    Returns
    -------------------------------------------------
    parameter: float
        The parameter value obtained from the fit
    parameter_err: float
        The parameter error obtained from the fit

    &#34;&#34;&#34;

    if self._fix_bkg_pars_[idx][par]:
        parameter = self._init_bkg_pars_[idx][par]
        parameter_err = 0.
    else:
        parameter = self._fit_result_.params[f&#39;{self._name_}_{par}_bkg{idx}&#39;][&#39;value&#39;]
        parameter_err = self._fit_result_.params[f&#39;{self._name_}_{par}_bkg{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

    return parameter, parameter_err</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_chi2"><code class="name flex">
<span>def <span class="ident">get_chi2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get chi2 for binned data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chi2</code></strong> :&ensp;<code>float</code></dt>
<dd>chi2</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chi2(self):
    &#34;&#34;&#34;
    Get chi2 for binned data

    Returns
    -------------------------------------------------
    chi2: float
        chi2
    &#34;&#34;&#34;

    chi2 = 0
    norm = self._data_handler_.get_norm()
    if self._data_handler_.get_is_binned():
        # for chi2 loss, just retrieve loss value in fit result
        if self._chi2_loss_:
            return float(self._fit_result_.loss.value())

        # for nll loss, compute chi2 &#34;by hand&#34;
        # access normalized data values and errors for all bins
        binned_data = self._data_handler_.get_binned_data()
        data_values = binned_data.values()
        data_variances = binned_data.variances()
        # access model predicted values
        model_values = self._total_pdf_binned_.values()*norm
        # compute chi2
        for (data, model, data_variance) in zip(data_values, model_values, data_variances):
            chi2 += (data - model)**2/data_variance
        return chi2

    # for unbinned data
    data_values = self._data_handler_.get_binned_data_from_unbinned_data()
    # access model predicted values
    model_values = self._total_pdf_binned_.values()*norm
    # compute chi2
    for (data, model) in zip(data_values, model_values):
        chi2 += (data - model)**2/data

    return float(chi2)</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_chi2_ndf"><code class="name flex">
<span>def <span class="ident">get_chi2_ndf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the reduced chi2 (chi2 divided by number of degrees of freedom)
for binned data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chi2_ndf</code></strong> :&ensp;<code>float</code></dt>
<dd>The reduced chi2</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chi2_ndf(self):
    &#34;&#34;&#34;
    Get the reduced chi2 (chi2 divided by number of degrees of freedom)
    for binned data

    Returns
    -------------------------------------------------
    chi2_ndf: float
        The reduced chi2
    &#34;&#34;&#34;
    return self.get_chi2()/self.get_ndf()</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_hwhm"><code class="name flex">
<span>def <span class="ident">get_hwhm</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the half width half maximum and its error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the sigma to be returned (default: 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hwhm</code></strong> :&ensp;<code>float</code></dt>
<dd>The sigma value obtained from the fit</dd>
<dt><strong><code>hwhm_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The sigma error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hwhm(self, idx=0):
    &#34;&#34;&#34;
    Get the half width half maximum and its error

    Parameters
    -------------------------------------------------
    idx: int
        Index of the sigma to be returned (default: 0)

    Returns
    -------------------------------------------------
    hwhm: float
        The sigma value obtained from the fit
    hwhm_err: float
        The sigma error obtained from the fit
    &#34;&#34;&#34;
    if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
        Logger(f&#39;HFWM parameter not defined for {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;ERROR&#39;)
        return 0., 0.

    if self._name_signal_pdf_[idx] == &#39;gaussian&#39;:
        mult_fact = np.sqrt(2 * np.log(2))
        hwhm, hwhm_err = self.get_sigma(idx)
        hwhm *= mult_fact
        hwhm_err *= mult_fact
    elif self._name_signal_pdf_[idx] == &#39;cauchy&#39;:
        hwhm, hwhm_err = self.get_signal_parameter(idx, &#39;gamma&#39;)
    elif self._name_signal_pdf_[idx] == &#39;voigtian&#39;:
        mult_fact = np.sqrt(2 * np.log(2))
        sigma, sigma_err = self.get_sigma(idx)
        sigma *= mult_fact
        sigma_err *= mult_fact
        gamma, gamma_err = self.get_signal_parameter(idx, &#39;gamma&#39;)
        hwhm = 0.5346 * gamma + np.sqrt(0.2166 * gamma**2 + sigma**2)
        # we neglect the correlation between sigma and gamma
        der_sigma = sigma / np.sqrt(0.0721663 + sigma**2)
        der_gamma = 0.5346 + (0.2166 * gamma) / np.sqrt(0.2166 * gamma**2 + sigma**2)
        hwhm_err = np.sqrt(der_sigma**2 * sigma_err**2 + der_gamma**2 * gamma_err**2)

    return hwhm, hwhm_err</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_mass"><code class="name flex">
<span>def <span class="ident">get_mass</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the mass and its error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the mass to be returned (default: 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mass</code></strong> :&ensp;<code>float</code></dt>
<dd>The mass value obtained from the fit</dd>
<dt><strong><code>mass_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The mass error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mass(self, idx=0):
    &#34;&#34;&#34;
    Get the mass and its error

    Parameters
    -------------------------------------------------
    idx: int
        Index of the mass to be returned (default: 0)

    Returns
    -------------------------------------------------
    mass: float
        The mass value obtained from the fit
    mass_err: float
        The mass error obtained from the fit
    &#34;&#34;&#34;
    if &#39;hist&#39; in self._name_signal_pdf_[idx]:
        hist = self._signal_pdf_[idx].to_hist()
        bin_limits = hist.to_numpy()[1]
        centres = [0.5 * (minn + maxx) for minn, maxx in zip(bin_limits[1:],  bin_limits[:-1])]
        counts = hist.values()
        mass = np.average(centres, weights=counts)
        mass_err = 0.
    else:
        mass_name = &#39;m&#39; if self._name_signal_pdf_[idx] == &#39;cauchy&#39; else &#39;mu&#39;
        if self._fix_sgn_pars_[idx][mass_name]:
            mass = self._init_sgn_pars_[idx][mass_name]
            mass_err = 0.
        else:
            mass = self._fit_result_.params[f&#39;{self._name_}_{mass_name}_signal{idx}&#39;][&#39;value&#39;]
            mass_err = self._fit_result_.params[f&#39;{self._name_}_{mass_name}_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

    return mass, mass_err</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_ndf"><code class="name flex">
<span>def <span class="ident">get_ndf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the number of degrees of freedom for chi2 fit
ndf = nbins - nfreeparams - 1
-1 because the data sample size is fixed</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ndf</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of degrees of freedom</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ndf(self):
    &#34;&#34;&#34;
    Get the number of degrees of freedom for chi2 fit
    ndf = nbins - nfreeparams - 1
    -1 because the data sample size is fixed

    Returns
    -------------------------------------------------
    ndf: int
        The number of degrees of freedom
    &#34;&#34;&#34;
    nbins = self._data_handler_.get_nbins()
    nfreeparams =  len(self._fit_result_.params)
    self._ndf_ = nbins - nfreeparams - 1
    return self._ndf_</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_raw_residuals"><code class="name flex">
<span>def <span class="ident">get_raw_residuals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the raw residuals (data_value - bkg_model_value) for all bins</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>residuals</code></strong> :&ensp;<code>array[float]</code></dt>
<dd>The residuals</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_residuals(self):
    &#34;&#34;&#34;
    Get the raw residuals (data_value - bkg_model_value) for all bins

    Returns
    -------------------------------------------------
    residuals: array[float]
        The residuals
    &#34;&#34;&#34;

    bins = self._data_handler_.get_nbins()
    norm = self._data_handler_.get_norm()
    residuals = [None]*bins
    background_pdf_binned_ = [None for _ in enumerate(self._name_background_pdf_)]
    model_bkg_values = [None for _ in enumerate(self._name_background_pdf_)]

    # access normalized data values and errors for all bins
    if self._data_handler_.get_is_binned():
        binned_data = self._data_handler_.get_binned_data()
        data_values = binned_data.values()
        variances = binned_data.variances()
        obs = self._data_handler_.get_obs()
    else:
        data_values = self._data_handler_.get_binned_data_from_unbinned_data()
        variances = data_values # poissonian errors
        obs = self._data_handler_.get_binned_obs_from_unbinned_data()

    # get background fractions
    if len(self._background_pdf_) == 1:
        signal_fracs, _, refl_fracs, _, _, _ = self.__get_all_fracs()
        bkg_fracs = [1 - sum(signal_fracs) - sum(refl_fracs)]
    else:
        _, bkg_fracs, _, _, _, _ = self.__get_all_fracs()
    # access model predicted values for background
    for ipdf, _ in enumerate(self._name_background_pdf_):
        background_pdf_binned_[ipdf] = zfit.pdf.BinnedFromUnbinnedPDF(self._background_pdf_[ipdf], obs)
        model_bkg_values[ipdf] = background_pdf_binned_[ipdf].values()*bkg_fracs[ipdf]*norm
    # compute residuals
    for ibin, data in enumerate(data_values):
        residuals[ibin] = float(data)
        for ipdf, _ in enumerate(self._name_background_pdf_):
            residuals[ibin] -= model_bkg_values[ipdf][ibin]

    return residuals, variances</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_raw_yield"><code class="name flex">
<span>def <span class="ident">get_raw_yield</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the raw yield and its error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the raw yield to be returned (default: 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>raw_yield</code></strong> :&ensp;<code>float</code></dt>
<dd>The raw yield obtained from the fit</dd>
<dt><strong><code>raw_yield_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The raw yield error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_yield(self, idx=0):
    &#34;&#34;&#34;
    Get the raw yield and its error

    Parameters
    -------------------------------------------------
    idx: int
        Index of the raw yield to be returned (default: 0)

    Returns
    -------------------------------------------------
    raw_yield: float
        The raw yield obtained from the fit
    raw_yield_err: float
        The raw yield error obtained from the fit
    &#34;&#34;&#34;
    return self._rawyield_[idx], self._rawyield_err_[idx]</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_sigma"><code class="name flex">
<span>def <span class="ident">get_sigma</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the sigma and its error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the sigma to be returned (default: 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code></dt>
<dd>The sigma value obtained from the fit</dd>
<dt><strong><code>sigma_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The sigma error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sigma(self, idx=0):
    &#34;&#34;&#34;
    Get the sigma and its error

    Parameters
    -------------------------------------------------
    idx: int
        Index of the sigma to be returned (default: 0)

    Returns
    -------------------------------------------------
    sigma: float
        The sigma value obtained from the fit
    sigma_err: float
        The sigma error obtained from the fit
    &#34;&#34;&#34;
    if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;voigtian&#39;, &#39;hist&#39;]:
        Logger(f&#39;Sigma parameter not defined for {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;ERROR&#39;)
        return 0., 0.

    # if histogram, the rms is used as proxy
    if &#39;hist&#39; in self._name_signal_pdf_[idx]:
        Logger(f&#39;RMS used as proxy for sigma parameter of {self._name_signal_pdf_[idx]} pdf!&#39;, &#39;WARNING&#39;)
        mean = self.get_mass(idx)[0]
        hist = self._signal_pdf_[idx].to_hist()
        bin_limits = hist.to_numpy()[1]
        centres = [0.5 * (minn + maxx) for minn, maxx in zip(bin_limits[1:],  bin_limits[:-1])]
        counts = hist.values()
        sigma = np.sqrt(np.average((centres - mean)**2, weights=counts))
        sigma_err = 0.
    else:
        if self._fix_sgn_pars_[idx][&#39;sigma&#39;]:
            sigma = self._init_sgn_pars_[idx][&#39;sigma&#39;]
            sigma_err = 0.
        else:
            sigma = self._fit_result_.params[f&#39;{self._name_}_sigma_signal{idx}&#39;][&#39;value&#39;]
            sigma_err = self._fit_result_.params[f&#39;{self._name_}_sigma_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

    return sigma, sigma_err</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_signal"><code class="name flex">
<span>def <span class="ident">get_signal</span></span>(<span>self, idx=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the signal and its error in a given invariant-mass region</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal to be returned</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>nsigma: float
nsigma invariant-mass window around mean for signal computation</p>
</li>
<li>
<p>nhwhm: float
number of hwhm invariant-mass window around mean for signal and background computation
(alternative to nsigma)</p>
</li>
<li>
<p>min: float
minimum value of invariant-mass for signal computation (alternative to nsigma)</p>
</li>
<li>
<p>max: float
maximum value of invariant-mass for signal computation (alternative to nsigma)</p>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>float</code></dt>
<dd>The signal value obtained from the fit</dd>
<dt><strong><code>signal_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The signal error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_signal(self, idx=0, **kwargs):
    &#34;&#34;&#34;
    Get the signal and its error in a given invariant-mass region

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal to be returned
    **kwargs: dict
        Additional optional arguments:

        - nsigma: float
            nsigma invariant-mass window around mean for signal computation

        - nhwhm: float
            number of hwhm invariant-mass window around mean for signal and background computation
            (alternative to nsigma)

        - min: float
            minimum value of invariant-mass for signal computation (alternative to nsigma)

        - max: float
            maximum value of invariant-mass for signal computation (alternative to nsigma)

    Returns
    -------------------------------------------------
    signal: float
        The signal value obtained from the fit
    signal_err: float
        The signal error obtained from the fit
    &#34;&#34;&#34;

    nsigma = kwargs.get(&#39;nsigma&#39;, 3.)
    nhwhm = kwargs.get(&#39;nhwhm&#39;, None)
    min_value = kwargs.get(&#39;min&#39;, None)
    max_value = kwargs.get(&#39;max&#39;, None)
    use_nsigma = True

    if nhwhm is not None and (min_value is not None or max_value is not None):
        Logger(&#39;I cannot compute the signal within a fixed mass interval and a number of HWFM&#39;, &#39;ERROR&#39;)
        return 0., 0.

    if min_value is not None and max_value is not None:
        use_nsigma = False

    if nhwhm is not None:
        use_nsigma = False
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;cauchy&#39;, &#39;voigtian&#39;]:
            Logger(&#39;HWHM not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
            return 0., 0.
        mass, _ = self.get_mass(idx)
        hwhm, _ = self.get_hwhm(idx)
        min_value = mass - nhwhm * hwhm
        max_value = mass + nhwhm * hwhm

    if use_nsigma:
        if self._name_signal_pdf_[idx] not in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;hist&#39;]:
            Logger(&#39;Sigma not defined, I cannot compute the signal for this pdf&#39;, &#39;ERROR&#39;)
            return 0., 0.
        mass, _ = self.get_mass(idx)
        sigma, _ = self.get_sigma(idx)
        min_value = mass - nsigma * sigma
        max_value = mass + nsigma * sigma

    # pylint: disable=missing-kwoa
    signal = self._signal_pdf_[idx].integrate((min_value, max_value))

    signal_fracs, refl_fracs, _, signal_err_fracs, _, _ = self.__get_all_fracs()

    if len(self._background_pdf_) &gt; 0:
        frac = signal_fracs[idx]
        frac_err = signal_err_fracs[idx]
    else:
        if len(self._signal_pdf_) == 1:
            frac = 1.
            frac_err = 0.
        if idx &lt; len(signal_fracs):
            frac = signal_fracs[idx]
            frac_err = signal_err_fracs[idx]
        else:
            frac = 1. - sum(signal_fracs) - sum(refl_fracs)
            frac_err = np.sqrt(sum(list(err**2 for err in signal_err_fracs)))

    norm = self._data_handler_.get_norm()
    norm_err = norm * frac_err
    norm *= frac

    return float(signal * norm), float(signal * norm_err)</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_signal_over_background"><code class="name flex">
<span>def <span class="ident">get_signal_over_background</span></span>(<span>self, idx=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the S/B ratio and its error in a given invariant-mass region</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal to be used to compute nsigma window</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>nsigma: float
nsigma invariant-mass window around mean for signal and background computation</p>
</li>
<li>
<p>nhwhm: float
number of hwhm invariant-mass window around mean for signal and background computation
(alternative to nsigma)</p>
</li>
<li>
<p>min: float
minimum value of invariant-mass for signal and background computation (alternative to nsigma)</p>
</li>
<li>
<p>max: float
maximum value of invariant-mass for signal and background computation (alternative to nsigma)</p>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>signal_over_background</code></strong> :&ensp;<code>float</code></dt>
<dd>The S/B value obtained from the fit</dd>
<dt><strong><code>signal_over_background_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The S/B error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_signal_over_background(self, idx=0, **kwargs):
    &#34;&#34;&#34;
    Get the S/B ratio and its error in a given invariant-mass region

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal to be used to compute nsigma window
    **kwargs: dict
        Additional optional arguments:

        - nsigma: float
            nsigma invariant-mass window around mean for signal and background computation

        - nhwhm: float
            number of hwhm invariant-mass window around mean for signal and background computation
            (alternative to nsigma)

        - min: float
            minimum value of invariant-mass for signal and background computation (alternative to nsigma)

        - max: float
            maximum value of invariant-mass for signal and background computation (alternative to nsigma)

    Returns
    -------------------------------------------------
    signal_over_background: float
        The S/B value obtained from the fit
    signal_over_background_err: float
        The S/B error obtained from the fit
    &#34;&#34;&#34;

    signal = self.get_signal(idx, **kwargs)
    bkg = self.get_background(idx, **kwargs)
    signal_over_background = signal[0]/bkg[0]
    signal_over_background_err = np.sqrt(signal[1]**2/signal[0]**2 + bkg[1]**2/bkg[0]**2)
    signal_over_background_err *= signal_over_background

    return signal_over_background, signal_over_background_err</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_signal_parameter"><code class="name flex">
<span>def <span class="ident">get_signal_parameter</span></span>(<span>self, idx, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a signal parameter and its error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the parameter to be returned (default: 0)</dd>
<dt><strong><code>par</code></strong> :&ensp;<code>str</code></dt>
<dd>parameter to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code>float</code></dt>
<dd>The parameter value obtained from the fit</dd>
<dt><strong><code>parameter_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The parameter error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_signal_parameter(self, idx, par):
    &#34;&#34;&#34;
    Get a signal parameter and its error

    Parameters
    -------------------------------------------------
    idx: int
        Index of the parameter to be returned (default: 0)
    par: str
        parameter to return

    Returns
    -------------------------------------------------
    parameter: float
        The parameter value obtained from the fit
    parameter_err: float
        The parameter error obtained from the fit

    &#34;&#34;&#34;

    if self._fix_sgn_pars_[idx][par]:
        parameter = self._init_sgn_pars_[idx][par]
        parameter_err = 0.
    else:
        parameter = self._fit_result_.params[f&#39;{self._name_}_{par}_signal{idx}&#39;][&#39;value&#39;]
        parameter_err = self._fit_result_.params[f&#39;{self._name_}_{par}_signal{idx}&#39;][&#39;hesse&#39;][&#39;error&#39;]

    return parameter, parameter_err</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_significance"><code class="name flex">
<span>def <span class="ident">get_significance</span></span>(<span>self, idx=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the significance and its error in a given invariant-mass region</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal to be used to compute nsigma window</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>nsigma: float
nsigma invariant-mass window around mean for signal and background computation</p>
</li>
<li>
<p>nhwhm: float
number of hwhm invariant-mass window around mean for signal and background computation
(alternative to nsigma)</p>
</li>
<li>
<p>min: float
minimum value of invariant-mass for signal and background computation (alternative to nsigma)</p>
</li>
<li>
<p>max: float
maximum value of invariant-mass for signal and background computation (alternative to nsigma)</p>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>significance</code></strong> :&ensp;<code>float</code></dt>
<dd>The significance value obtained from the fit</dd>
<dt><strong><code>significance_err</code></strong> :&ensp;<code>float</code></dt>
<dd>The significance error obtained from the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_significance(self, idx=0, **kwargs):
    &#34;&#34;&#34;
    Get the significance and its error in a given invariant-mass region

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal to be used to compute nsigma window
    **kwargs: dict
        Additional optional arguments:

        - nsigma: float
            nsigma invariant-mass window around mean for signal and background computation

        - nhwhm: float
            number of hwhm invariant-mass window around mean for signal and background computation
            (alternative to nsigma)

        - min: float
            minimum value of invariant-mass for signal and background computation (alternative to nsigma)

        - max: float
            maximum value of invariant-mass for signal and background computation (alternative to nsigma)

    Returns
    -------------------------------------------------
    significance: float
        The significance value obtained from the fit
    significance_err: float
        The significance error obtained from the fit
    &#34;&#34;&#34;

    signal = self.get_signal(idx, **kwargs)
    bkg = self.get_background(idx, **kwargs)
    significance = signal[0]/np.sqrt(signal[0]+bkg[0])
    sig_plus_bkg = signal[0] + bkg[0]

    significance_err = significance*np.sqrt(
        (signal[1]**2 + bkg[1]**2) / (4. * sig_plus_bkg**2) + (
            bkg[0]/sig_plus_bkg) * signal[1]**2 / signal[0]**2)

    return significance, significance_err</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.get_std_residuals"><code class="name flex">
<span>def <span class="ident">get_std_residuals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the standardized residuals
(data_value - bkg_model_value)/ sigma_data for all bins</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>residuals</code></strong> :&ensp;<code>array[float]</code></dt>
<dd>The standardized residuals</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_std_residuals(self):
    &#34;&#34;&#34;
    Get the standardized residuals
    (data_value - bkg_model_value)/ sigma_data for all bins

    Returns
    -------------------------------------------------
    residuals: array[float]
        The standardized residuals
    &#34;&#34;&#34;

    bins = self._data_handler_.get_nbins()
    norm = self._data_handler_.get_norm()
    residuals, residuals_variances = [None]*bins, [None]*bins

    # access normalized data values and errors for all bins
    if self._data_handler_.get_is_binned():
        binned_data = self._data_handler_.get_binned_data()
        data_values = binned_data.values()
        variances = binned_data.variances()
    else:
        data_values = self._data_handler_.get_binned_data_from_unbinned_data()
        variances = data_values # poissonian errors

    # access model predicted values for background
    self.__build_total_pdf_binned()
    model_values = self._total_pdf_binned_.values()*norm
    for ibin, (data, model, variance) in enumerate(zip(data_values, model_values, variances)):
        if variance == 0:
            Logger(&#39;Null variance. Consider enlarging the bins.&#39;, &#39;FATAL&#39;)
        residuals[ibin] = float((data - model)/np.sqrt(variance))
        residuals_variances[ibin] = float(variance/np.sqrt(variance))

    return residuals, residuals_variances</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.mass_zfit"><code class="name flex">
<span>def <span class="ident">mass_zfit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a mass fit with the zfit library</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fit_result</code></strong> :&ensp;<code>zfit.minimizers.fitresult.FitResult</code></dt>
<dd>The fit result</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass_zfit(self):
    &#34;&#34;&#34;
    Perform a mass fit with the zfit library

    Returns
    -------------------------------------------------
    fit_result: zfit.minimizers.fitresult.FitResult
        The fit result
    &#34;&#34;&#34;

    if self._data_handler_ is None:
        Logger(&#39;Data handler not specified&#39;, &#39;FATAL&#39;)

    self.__build_total_pdf()
    self.__build_total_pdf_binned()
    # pylint: disable=fixme
    self.__prefit() #TODO: implement me

    if self._data_handler_.get_is_binned():
        # chi2 loss
        if self._chi2_loss_:
            loss = zfit.loss.BinnedChi2(self._total_pdf_binned_, self._data_handler_.get_binned_data())
        # nll loss
        else:
            loss = zfit.loss.BinnedNLL(self._total_pdf_binned_, self._data_handler_.get_binned_data())
    else:
        loss = zfit.loss.UnbinnedNLL(model=self._total_pdf_, data=self._data_handler_.get_data())

    self._fit_result_ = self._minimizer_.minimize(loss=loss)
    Logger(self._fit_result_, &#39;RESULT&#39;)

    if self._fit_result_.hesse() == {}:
        if self._fit_result_.hesse(method=&#39;hesse_np&#39;) == {}:
            Logger(&#39;Impossible to compute hesse error&#39;, &#39;FATAL&#39;)

    norm = self._data_handler_.get_norm()
    if len(self._fracs_) == 0:
        self._rawyield_ = self._data_handler_.get_norm()
        self._rawyield_err_ = np.sqrt(self._rawyield_)
    else:
        for ipdf, _ in enumerate(self._signal_pdf_):
            if len(self._background_pdf_) &gt; 0 or ipdf &lt; len(self._signal_pdf_) - 1:
                self._rawyield_[ipdf] = self._fit_result_.params[
                    f&#39;{self._name_}_frac_signal{ipdf}&#39;][&#39;value&#39;] * norm
                self._rawyield_err_[ipdf] = self._fit_result_.params[
                    f&#39;{self._name_}_frac_signal{ipdf}&#39;][&#39;hesse&#39;][&#39;error&#39;] * norm
            else:
                frac, frac_err = 0., 0.
                for ipdf2 in range(len(self._signal_pdf_)-1):
                    frac += self._fit_result_.params[
                        f&#39;{self._name_}_frac_signal{ipdf2}&#39;][&#39;value&#39;]
                    frac_err += np.sqrt(self._fit_result_.params[
                        f&#39;{self._name_}_frac_signal{ipdf2}&#39;][&#39;hesse&#39;][&#39;error&#39;])
                self._rawyield_[ipdf] = frac * norm
                self._rawyield_err_[ipdf] = frac_err * norm

    return self._fit_result_</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.plot_mass_fit"><code class="name flex">
<span>def <span class="ident">plot_mass_fit</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the mass fit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>style: str
style to be used (see <a href="https://github.com/scikit-hep/mplhep">https://github.com/scikit-hep/mplhep</a> for more details)</p>
</li>
<li>
<p>logy: bool
log scale in y axis</p>
</li>
<li>
<p>figsize: tuple
size of the figure</p>
</li>
<li>
<p>axis_title: str
x-axis title</p>
</li>
<li>
<p>show_extra_info: bool
show mu, sigma, chi2/ndf, signal, bkg, signal/bkg, significance</p>
</li>
<li>
<p>extra_info_massnsigma: float
number of sigmas for extra info</p>
</li>
<li>
<p>extra_info_massnhwhm: float
number of hwhms for extra info (alternative to extra_info_massnsigma)</p>
</li>
<li>
<p>extra_info_massrange: list
mass range limits for extra info (alternative to extra_info_massnsigma)</p>
</li>
<li>
<p>extra_info_loc: list
location of extra info (one for chi2 and one for other info)</p>
</li>
<li>
<p>num: int
number of bins to plot pdfs converted into histograms</p>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>figure containing the mass fit plot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mass_fit(self, **kwargs):
    &#34;&#34;&#34;
    Plot the mass fit

    Parameters
    -------------------------------------------------
    **kwargs: dict
        Additional optional arguments:

        - style: str
            style to be used (see https://github.com/scikit-hep/mplhep for more details)

        - logy: bool
            log scale in y axis

        - figsize: tuple
            size of the figure

        - axis_title: str
            x-axis title

        - show_extra_info: bool
            show mu, sigma, chi2/ndf, signal, bkg, signal/bkg, significance

        - extra_info_massnsigma: float
            number of sigmas for extra info

        - extra_info_massnhwhm: float
            number of hwhms for extra info (alternative to extra_info_massnsigma)

        - extra_info_massrange: list
            mass range limits for extra info (alternative to extra_info_massnsigma)

        - extra_info_loc: list
            location of extra info (one for chi2 and one for other info)

        - num: int
            number of bins to plot pdfs converted into histograms

    Returns
    -------------------------------------------------
    fig: matplotlib.figure.Figure
        figure containing the mass fit plot
    &#34;&#34;&#34;

    style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
    logy = kwargs.get(&#39;logy&#39;, False)
    figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
    bins = self._data_handler_.get_nbins()
    axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())
    show_extra_info = kwargs.get(&#39;show_extra_info&#39;, False)
    num = kwargs.get(&#39;num&#39;, 10000)
    mass_range = kwargs.get(&#39;extra_info_massrange&#39;, None)
    nhwhm = kwargs.get(&#39;extra_info_massnhwhm&#39;, None)
    nsigma = kwargs.get(&#39;extra_info_massnsigma&#39;, 3)
    loc = kwargs.get(&#39;extra_info_loc&#39;, [&#39;upper left&#39;, &#39;lower right&#39;])

    mplhep.style.use(style)

    obs = self._data_handler_.get_obs()
    limits = self._data_handler_.get_limits()

    fig, axs = plt.subplots(figsize=figsize)

    hdata = self._data_handler_.to_hist(lower_edge=limits[0],
                                        upper_edge=limits[1],
                                        nbins=bins,
                                        varname=self._data_handler_.get_var_name())

    hdata.plot(yerr=True, color=&#39;black&#39;, histtype=&#39;errorbar&#39;, label=&#39;data&#39;)
    bin_sigma = (limits[1] - limits[0]) / bins
    norm = self._data_handler_.get_norm() * bin_sigma

    x_plot = np.linspace(limits[0], limits[1], num=num)
    total_func = zfit.run(self._total_pdf_.pdf(x_plot, norm_range=obs))
    signal_funcs, refl_funcs, bkg_funcs = ([] for _ in range(3))
    for signal_pdf in self._signal_pdf_:
        signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
    for refl_pdf in self._refl_pdf_:
        refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))
    for bkg_pdf in self._background_pdf_:
        bkg_funcs.append(zfit.run(bkg_pdf.pdf(x_plot, norm_range=obs)))

    signal_fracs, bkg_fracs, refl_fracs, _, _, _ = self.__get_all_fracs()

    # first draw backgrounds
    for ibkg, bkg_func in enumerate(bkg_funcs):
        if ibkg &lt; len(bkg_fracs) - 1:
            plt.plot(x_plot, bkg_func * norm * bkg_fracs[ibkg], color=self._bkg_cmap_(ibkg),
                     ls=&#39;--&#39;, label=f&#39;background {ibkg}&#39;)
        else:
            plt.plot(x_plot, bkg_func * norm * (1-sum(bkg_fracs)-sum(signal_fracs)-sum(refl_fracs)),
                     color=&#39;firebrick&#39;, ls=&#39;--&#39;, label=f&#39;background {ibkg}&#39;)
    # then draw signals
    for isgn, (signal_func, frac) in enumerate(zip(signal_funcs, signal_fracs)):
        plt.plot(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn))
        plt.fill_between(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn),
                         alpha=0.5, label=f&#39;signal {isgn}&#39;)

    # finally draw reflected signals (if any)
    for irefl, (refl_func, frac) in enumerate(zip(refl_funcs, refl_fracs)):
        if self._name_refl_pdf_[irefl] is None:
            continue
        plt.plot(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl))
        plt.fill_between(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl),
                         alpha=0.5, label=f&#39;reflected signal {irefl}&#39;)

    plt.plot(x_plot, total_func * norm, color=&#39;xkcd:blue&#39;, label=&#39;total fit&#39;)
    plt.xlim(limits[0], limits[1])
    plt.xlabel(axis_title)
    plt.ylabel(rf&#39;counts / {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#39;)
    plt.legend(loc=&#39;best&#39;)
    if logy:
        plt.yscale(&#39;log&#39;)
        plt.ylim(min(total_func) * norm / 5, max(total_func) * norm * 5)

    if show_extra_info:
        # info on chi2/ndf
        chi2 = self.get_chi2()
        ndf = self.get_ndf()
        anchored_text_chi2 = AnchoredText(fr&#39;$\chi^2 / \mathrm{{ndf}} =${chi2:.2f} / {ndf}&#39;,
                                          loc = loc[0],
                                          frameon=False)
        # signal and background info for all signals
        text = []
        for idx, _ in enumerate(self._name_signal_pdf_):
            mass, mass_unc = self.get_mass(idx)
            sigma, sigma_unc = None, None
            gamma, gamma_unc = None, None
            if self._name_signal_pdf_[idx] in [&#39;gaussian&#39;, &#39;crystalball&#39;, &#39;voigtian&#39;, &#39;hist&#39;]:
                sigma, sigma_unc = self.get_sigma(idx)
            if self._name_signal_pdf_[idx] in [&#39;cauchy&#39;, &#39;voigtian&#39;]:
                gamma, gamma_unc = self.get_signal_parameter(idx, &#39;gamma&#39;)
            extra_info = fr&#39;signal{idx}&#39;&#39;\n&#39; + fr&#39;  $\mu = {mass*1000:.1f}\pm{mass_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
            if sigma is not None:
                extra_info += fr&#39;  $\sigma = {sigma*1000:.1f}\pm{sigma_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
            if gamma is not None:
                extra_info += fr&#39;  $\Gamma = {gamma*1000:.1f}\pm{gamma_unc*1000:.1f}$ MeV$/c^2$&#39;&#39;\n&#39;
            if mass_range is not None:
                signal, signal_err = self.get_signal(idx=idx, min=mass_range[0], max=mass_range[1])
                bkg, bkg_err = self.get_background(idx=idx, min=mass_range[0], max=mass_range[1])
                s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, min=mass_range[0],
                                                                         max=mass_range[1])
                signif, signif_err = self.get_significance(idx=idx, min=mass_range[0],
                                                                       max=mass_range[1])
                interval = f&#39;[{mass_range[0]:.3f}, {mass_range[1]:.3f}]&#39;
                extra_info += fr&#39;  $S({interval})={signal:.0f} \pm {signal_err:.0f}$&#39;&#39;\n&#39;
                extra_info += fr&#39;  $B({interval})={bkg:.0f} \pm {bkg_err:.0f}$&#39;&#39;\n&#39;
                extra_info += fr&#39;  $S/B({interval})={s_over_b:.2f} \pm {s_over_b_err:.2f}$&#39;&#39;\n&#39;
                extra_info += fr&#39;  Signif.$({interval})={signif:.1f} \pm {signif_err:.1f}$&#39;
            elif nhwhm is not None:
                signal, signal_err = self.get_signal(idx=idx, nhwhm=nhwhm)
                bkg, bkg_err = self.get_background(idx=idx, nhwhm=nhwhm)
                s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, nhwhm=nhwhm)
                signif, signif_err = self.get_significance(idx=idx, nhwhm=nhwhm)
                extra_info += fr&#39;  $S=${signal:.0f} $\pm$ {signal_err:.0f}&#39;&#39;\n&#39;
                extra_info += fr&#39;  $B({nhwhm}~\mathrm{{HWHM}})=${bkg:.0f} $\pm$ {bkg_err:.0f}&#39;&#39;\n&#39;
                extra_info += fr&#39;  $S/B({nhwhm}~\mathrm{{HWHM}})=${s_over_b:.2f} $\pm$ {s_over_b_err:.2f}&#39;&#39;\n&#39;
                extra_info += fr&#39;  Signif.$({nhwhm}~\mathrm{{HWHM}})=${signif:.1f} $\pm$ {signif_err:.1f}&#39;
            else:
                signal, signal_err = self.get_signal(idx=idx, nsigma=nsigma)
                bkg, bkg_err = self.get_background(idx=idx, nsigma=nsigma)
                s_over_b, s_over_b_err = self.get_signal_over_background(idx=idx, nsigma=nsigma)
                signif, signif_err = self.get_significance(idx=idx, nsigma=nsigma)
                extra_info += fr&#39;  $S=${signal:.0f} $\pm$ {signal_err:.0f}&#39;&#39;\n&#39;
                extra_info += fr&#39;  $B({nsigma}\sigma)=${bkg:.0f} $\pm$ {bkg_err:.0f}&#39;&#39;\n&#39;
                extra_info += fr&#39;  $S/B({nsigma}\sigma)=${s_over_b:.2f} $\pm$ {s_over_b_err:.2f}&#39;&#39;\n&#39;
                extra_info += fr&#39;  Signif.$({nsigma}\sigma)=${signif:.1f} $\pm$ {signif_err:.1f}&#39;
            text.append(extra_info)
        concatenated_text = &#39;\n&#39;.join(text)
        anchored_text_signal = AnchoredText(concatenated_text, loc = loc[1], frameon=False)

        axs.add_artist(anchored_text_chi2)
        axs.add_artist(anchored_text_signal)

    return fig</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.plot_raw_residuals"><code class="name flex">
<span>def <span class="ident">plot_raw_residuals</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the raw residuals</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>style: str
style to be used (see <a href="https://github.com/scikit-hep/mplhep">https://github.com/scikit-hep/mplhep</a> for more details)</p>
</li>
<li>
<p>figsize: tuple
size of the figure</p>
</li>
<li>
<p>axis_title: str
x-axis title</p>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>figure containing the raw residuals plot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_raw_residuals(self, **kwargs):
    &#34;&#34;&#34;
    Plot the raw residuals

    Parameters
    -------------------------------------------------
    **kwargs: dict
        Additional optional arguments:

        - style: str
            style to be used (see https://github.com/scikit-hep/mplhep for more details)

        - figsize: tuple
            size of the figure

        - axis_title: str
            x-axis title

    Returns
    -------------------------------------------------
    fig: matplotlib.figure.Figure
        figure containing the raw residuals plot
    &#34;&#34;&#34;

    style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
    figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
    axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())

    mplhep.style.use(style)

    obs = self._data_handler_.get_obs()
    limits = self._data_handler_.get_limits()

    fig = plt.figure(figsize=figsize)

    residuals, variances = self.get_raw_residuals()
    # draw residuals
    plt.errorbar(
        self._data_handler_.get_bin_center(),
        residuals,
        xerr = None,
        yerr = np.sqrt(variances),
        linestyle = &#34;None&#34;,
        elinewidth = 1,
        capsize = 0,
        color = &#34;black&#34;,
        marker = &#34;o&#34;,
        markersize = 5,
        label = &#34;residuals&#34;
    )
    bins = self._data_handler_.get_nbins()
    bin_sigma = (limits[1] - limits[0]) / bins
    norm = self._data_handler_.get_norm() * bin_sigma

    x_plot = np.linspace(limits[0], limits[1], num=1000)
    signal_funcs, refl_funcs = ([] for _ in range(2))
    for signal_pdf in self._signal_pdf_:
        signal_funcs.append(zfit.run(signal_pdf.pdf(x_plot, norm_range=obs)))
    for refl_pdf in self._refl_pdf_:
        refl_funcs.append(zfit.run(refl_pdf.pdf(x_plot, norm_range=obs)))

    signal_fracs, _, refl_fracs, _, _, _ = self.__get_all_fracs()

    # draw signals
    for isgn, (signal_func, frac) in enumerate(zip(signal_funcs, signal_fracs)):
        plt.plot(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn))
        plt.fill_between(x_plot, signal_func * norm * frac, color=self._sgn_cmap_(isgn),
                         alpha=0.5, label=f&#39;signal {isgn}&#39;)

    # finally draw reflected signals (if any)
    is_there_refl = False
    for irefl, (refl_func, frac) in enumerate(zip(refl_funcs, refl_fracs)):
        if self._name_refl_pdf_[irefl] is None:
            continue
        is_there_refl = True
        plt.plot(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl))
        plt.fill_between(x_plot, refl_func * norm * frac, color=self._refl_cmap_(irefl),
                         alpha=0.5, label=f&#39;reflected signal {irefl}&#39;)

    # draw signal + reflected signals (if any)
    if is_there_refl:
        for isgn, (signal_func, refl_func, frac_sgn, frac_refl) in enumerate(
            zip(signal_funcs, refl_funcs, signal_fracs, refl_fracs)):
            plt.plot(x_plot, (signal_func * frac_sgn + frac_refl * refl_func) * norm,
                    color=&#39;xkcd:blue&#39;, label=&#39;total - bkg&#39;)


    plt.xlim(limits[0], limits[1])
    plt.xlabel(axis_title)
    plt.ylabel(rf&#39;(data - fitted bkg) / {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#39;)
    plt.legend(loc=&#39;best&#39;)

    return fig</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.plot_std_residuals"><code class="name flex">
<span>def <span class="ident">plot_std_residuals</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the raw residuals</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>style: str
style to be used (see <a href="https://github.com/scikit-hep/mplhep">https://github.com/scikit-hep/mplhep</a> for more details)</p>
</li>
<li>
<p>figsize: tuple
size of the figure</p>
</li>
<li>
<p>axis_title: str
x-axis title</p>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>figure containing the raw residuals plot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_std_residuals(self, **kwargs):
    &#34;&#34;&#34;
    Plot the raw residuals

    Parameters
    -------------------------------------------------
    **kwargs: dict
        Additional optional arguments:

        - style: str
            style to be used (see https://github.com/scikit-hep/mplhep for more details)

        - figsize: tuple
            size of the figure

        - axis_title: str
            x-axis title

    Returns
    -------------------------------------------------
    fig: matplotlib.figure.Figure
        figure containing the raw residuals plot
    &#34;&#34;&#34;

    style = kwargs.get(&#39;style&#39;, &#39;LHCb2&#39;)
    figsize = kwargs.get(&#39;figsize&#39;, (7, 7))
    axis_title = kwargs.get(&#39;axis_title&#39;, self._data_handler_.get_var_name())

    mplhep.style.use(style)

    limits = self._data_handler_.get_limits()
    bins = self._data_handler_.get_nbins()
    bin_center = self._data_handler_.get_bin_center()

    fig = plt.figure(figsize=figsize)

    residuals, variances = self.get_std_residuals()
    # draw residuals
    plt.errorbar(bin_center,
                residuals,
                xerr = None,
                yerr = np.sqrt(variances),
                linestyle = &#34;None&#34;,
                elinewidth = 1,
                capsize = 0,
                color = &#34;black&#34;,
                marker = &#34;o&#34;,
                markersize = 5,
                label = None)

    # line at 0
    plt.plot([bin_center[0], bin_center[-1]], [0., 0.], lw=2, color=&#39;xkcd:blue&#39;)
    # line at -3 sigma
    plt.plot([bin_center[0], bin_center[-1]], [-3., -3.], lw=2, color=&#39;xkcd:red&#39;)
    # line at 3 sigma
    plt.plot([bin_center[0], bin_center[-1]], [3., 3.], lw=2, color=&#39;xkcd:red&#39;)

    plt.xlim(limits[0], limits[1])
    plt.xlabel(axis_title)
    plt.ylabel(fr&#34;$\dfrac{{ \mathrm{{data}} - \mathrm{{total \ fit}} }}{{ \sigma_{{ \mathrm{{data}} }} }}$&#34;
               fr&#34;/ {(limits[1]-limits[0])/bins*1000:0.1f} MeV/$c^2$&#34;)

    return fig</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_background_initpar"><code class="name flex">
<span>def <span class="ident">set_background_initpar</span></span>(<span>self, idx, par_name, init_value, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a background parameter</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the background</dd>
<dt><strong><code>par_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the parameter to be set</dd>
<dt><strong><code>init_value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of parameter to be set</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>limits: list
minimum and maximum limits for the parameter</p>
</li>
<li>
<p>fix: bool
fix the mass parameter</p>
</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_background_initpar(self, idx, par_name, init_value, **kwargs):
    &#34;&#34;&#34;
    Set a background parameter

    Parameters
    -------------------------------------------------
    idx: int
        Index of the background
    par_name: str
        The name of the parameter to be set
    init_value: float
        The value of parameter to be set
    **kwargs: dict
        Additional optional arguments:

        - limits: list
            minimum and maximum limits for the parameter

        - fix: bool
            fix the mass parameter
    &#34;&#34;&#34;
    self._init_bkg_pars_[idx][par_name] = init_value
    if &#39;limits&#39; in kwargs:
        self._limits_bkg_pars_[idx][par_name] = kwargs[&#39;limits&#39;]
    if &#39;fix&#39; in kwargs:
        self._fix_bkg_pars_[idx][par_name] = kwargs[&#39;fix&#39;]</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_background_kde"><code class="name flex">
<span>def <span class="ident">set_background_kde</span></span>(<span>self, idx, sample, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set sample and options for background kde</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the background</dd>
<dt><strong><code>sample</code></strong> :&ensp;<code>flarefly.DataHandler</code></dt>
<dd>Data sample for Kernel Density Estimation</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments for kde options. See
<a href="https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid">https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid</a>
for more details</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_background_kde(self, idx, sample, **kwargs):
    &#34;&#34;&#34;
    Set sample and options for background kde

    Parameters
    -------------------------------------------------
    idx: int
        Index of the background
    sample: flarefly.DataHandler
        Data sample for Kernel Density Estimation
    **kwargs: dict
        Arguments for kde options. See
        https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
        for more details
    &#34;&#34;&#34;

    self._kde_bkg_sample_[idx] = sample
    self._kde_bkg_option_[idx] = kwargs</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_background_template"><code class="name flex">
<span>def <span class="ident">set_background_template</span></span>(<span>self, idx, sample)</span>
</code></dt>
<dd>
<div class="desc"><p>Set sample and options for background template histogram</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the background</dd>
<dt><strong><code>sample</code></strong> :&ensp;<code>flarefly.DataHandler</code></dt>
<dd>Data sample for template histogram</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_background_template(self, idx, sample):
    &#34;&#34;&#34;
    Set sample and options for background template histogram

    Parameters
    -------------------------------------------------
    idx: int
        Index of the background
    sample: flarefly.DataHandler
        Data sample for template histogram
    &#34;&#34;&#34;

    self._hist_bkg_sample_[idx] = sample</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_particle_mass"><code class="name flex">
<span>def <span class="ident">set_particle_mass</span></span>(<span>self, idx, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the particle mass</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>mass: float
The mass of the particle</p>
</li>
<li>
<p>pdg_id: int
PDG ID of the particle (alternative to mass)</p>
</li>
<li>
<p>pdg_name: str
Name of the particle (alternative to mass)</p>
</li>
<li>
<p>limits: list
minimum and maximum limits for the mass parameter</p>
</li>
<li>
<p>fix: bool
fix the mass parameter</p>
</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_particle_mass(self, idx, **kwargs):
    &#34;&#34;&#34;
    Set the particle mass

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal
    **kwargs: dict
        Additional optional arguments:

        - mass: float
            The mass of the particle

        - pdg_id: int
            PDG ID of the particle (alternative to mass)

        - pdg_name: str
            Name of the particle (alternative to mass)

        - limits: list
            minimum and maximum limits for the mass parameter

        - fix: bool
            fix the mass parameter
    &#34;&#34;&#34;
    mass_name = &#39;m&#39; if self._name_signal_pdf_[idx] == &#39;cauchy&#39; else &#39;mu&#39;
    mass = 0.
    if &#39;mass&#39; in kwargs:
        mass = kwargs[&#39;mass&#39;]
    elif &#39;pdg_id&#39; in kwargs:
        mass = Particle.from_pdgid(kwargs[&#39;pdg_id&#39;]).mass*1e-3
    elif &#39;pdg_name&#39; in kwargs:
        mass = Particle.from_name(kwargs[&#39;pdg_name&#39;]).mass*1e-3
    else:
        Logger(f&#39;&#34;mass&#34;, &#34;pdg_id&#34;, and &#34;pdg_name&#34; not provided, mass value for signal {idx} will not be set&#39;,
               &#39;ERROR&#39;)
    self._init_sgn_pars_[idx][mass_name] = mass
    if &#39;limits&#39; in kwargs:
        self._limits_sgn_pars_[idx][mass_name] = kwargs[&#39;limits&#39;]
    if &#39;fix&#39; in kwargs:
        self._fix_sgn_pars_[idx][mass_name] = kwargs[&#39;fix&#39;]</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_reflection_kde"><code class="name flex">
<span>def <span class="ident">set_reflection_kde</span></span>(<span>self, idx, sample, r_over_s, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set sample and options for reflected signal kde</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal</dd>
<dt><strong><code>sample</code></strong> :&ensp;<code>flarefly.DataHandler</code></dt>
<dd>Data sample for Kernel Density Estimation</dd>
<dt><strong><code>r_over_s</code></strong> :&ensp;<code>float</code></dt>
<dd>R/S ratio</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments for kde options. See
<a href="https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid">https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid</a>
for more details</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_reflection_kde(self, idx, sample, r_over_s, **kwargs):
    &#34;&#34;&#34;
    Set sample and options for reflected signal kde

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal
    sample: flarefly.DataHandler
        Data sample for Kernel Density Estimation
    r_over_s: float
        R/S ratio
    **kwargs: dict
        Arguments for kde options. See
        https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
        for more details
    &#34;&#34;&#34;

    self._kde_signal_sample_[idx] = sample
    self._kde_signal_option_[idx] = kwargs
    self._refl_over_sgn_[idx] = r_over_s</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_reflection_template"><code class="name flex">
<span>def <span class="ident">set_reflection_template</span></span>(<span>self, idx, sample, r_over_s)</span>
</code></dt>
<dd>
<div class="desc"><p>Set sample and options for reflected signal template</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the reflected signal</dd>
<dt><strong><code>sample</code></strong> :&ensp;<code>flarefly.DataHandler</code></dt>
<dd>Data sample for histogram template</dd>
<dt><strong><code>r_over_s</code></strong> :&ensp;<code>float</code></dt>
<dd>R/S ratio</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_reflection_template(self, idx, sample, r_over_s):
    &#34;&#34;&#34;
    Set sample and options for reflected signal template

    Parameters
    -------------------------------------------------
    idx: int
        Index of the reflected signal
    sample: flarefly.DataHandler
        Data sample for histogram template
    r_over_s: float
        R/S ratio
    &#34;&#34;&#34;

    self._hist_refl_sample_[idx] = sample
    self._refl_over_sgn_[idx] = r_over_s</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_signal_initpar"><code class="name flex">
<span>def <span class="ident">set_signal_initpar</span></span>(<span>self, idx, par_name, init_value, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a signal parameter</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal</dd>
<dt><strong><code>par_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the parameter to be set</dd>
<dt><strong><code>init_value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of parameter to be set</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional optional arguments:</p>
<ul>
<li>
<p>limits: list
minimum and maximum limits for the parameter</p>
</li>
<li>
<p>fix: bool
fix the parameter to init_value</p>
</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_signal_initpar(self, idx, par_name, init_value, **kwargs):
    &#34;&#34;&#34;
    Set a signal parameter

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal
    par_name: str
        The name of the parameter to be set
    init_value: float
        The value of parameter to be set
    **kwargs: dict
        Additional optional arguments:

        - limits: list
            minimum and maximum limits for the parameter

        - fix: bool
            fix the parameter to init_value
    &#34;&#34;&#34;
    self._init_sgn_pars_[idx][par_name] = init_value
    if &#39;limits&#39; in kwargs:
        self._limits_sgn_pars_[idx][par_name] = kwargs[&#39;limits&#39;]
    if &#39;fix&#39; in kwargs:
        self._fix_sgn_pars_[idx][par_name] = kwargs[&#39;fix&#39;]</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_signal_kde"><code class="name flex">
<span>def <span class="ident">set_signal_kde</span></span>(<span>self, idx, sample, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set sample and options for signal kde</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal</dd>
<dt><strong><code>sample</code></strong> :&ensp;<code>flarefly.DataHandler</code></dt>
<dd>Data sample for Kernel Density Estimation</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments for kde options. See
<a href="https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid">https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid</a>
for more details</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_signal_kde(self, idx, sample, **kwargs):
    &#34;&#34;&#34;
    Set sample and options for signal kde

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal
    sample: flarefly.DataHandler
        Data sample for Kernel Density Estimation
    **kwargs: dict
        Arguments for kde options. See
        https://zfit.readthedocs.io/en/latest/user_api/pdf/_generated/kde_api/zfit.pdf.KDE1DimGrid.html#zfit.pdf.KDE1DimGrid
        for more details
    &#34;&#34;&#34;

    self._kde_signal_sample_[idx] = sample
    self._kde_signal_option_[idx] = kwargs</code></pre>
</details>
</dd>
<dt id="flarefly.fitter.F2MassFitter.set_signal_template"><code class="name flex">
<span>def <span class="ident">set_signal_template</span></span>(<span>self, idx, sample)</span>
</code></dt>
<dd>
<div class="desc"><p>Set sample and options for signal template</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the signal</dd>
<dt><strong><code>sample</code></strong> :&ensp;<code>flarefly.DataHandler</code></dt>
<dd>Data sample for histogram template</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_signal_template(self, idx, sample):
    &#34;&#34;&#34;
    Set sample and options for signal template

    Parameters
    -------------------------------------------------
    idx: int
        Index of the signal
    sample: flarefly.DataHandler
        Data sample for histogram template
    &#34;&#34;&#34;

    self._hist_signal_sample_[idx] = sample</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="flarefly" href="index.html">flarefly</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="flarefly.fitter.F2MassFitter" href="#flarefly.fitter.F2MassFitter">F2MassFitter</a></code></h4>
<ul class="">
<li><code><a title="flarefly.fitter.F2MassFitter.dump_to_root" href="#flarefly.fitter.F2MassFitter.dump_to_root">dump_to_root</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_background" href="#flarefly.fitter.F2MassFitter.get_background">get_background</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_background_parameter" href="#flarefly.fitter.F2MassFitter.get_background_parameter">get_background_parameter</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_chi2" href="#flarefly.fitter.F2MassFitter.get_chi2">get_chi2</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_chi2_ndf" href="#flarefly.fitter.F2MassFitter.get_chi2_ndf">get_chi2_ndf</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_fit_result" href="#flarefly.fitter.F2MassFitter.get_fit_result">get_fit_result</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_hwhm" href="#flarefly.fitter.F2MassFitter.get_hwhm">get_hwhm</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_mass" href="#flarefly.fitter.F2MassFitter.get_mass">get_mass</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_ndf" href="#flarefly.fitter.F2MassFitter.get_ndf">get_ndf</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_raw_residuals" href="#flarefly.fitter.F2MassFitter.get_raw_residuals">get_raw_residuals</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_raw_yield" href="#flarefly.fitter.F2MassFitter.get_raw_yield">get_raw_yield</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_sigma" href="#flarefly.fitter.F2MassFitter.get_sigma">get_sigma</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_signal" href="#flarefly.fitter.F2MassFitter.get_signal">get_signal</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_signal_over_background" href="#flarefly.fitter.F2MassFitter.get_signal_over_background">get_signal_over_background</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_signal_parameter" href="#flarefly.fitter.F2MassFitter.get_signal_parameter">get_signal_parameter</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_significance" href="#flarefly.fitter.F2MassFitter.get_significance">get_significance</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.get_std_residuals" href="#flarefly.fitter.F2MassFitter.get_std_residuals">get_std_residuals</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.mass_zfit" href="#flarefly.fitter.F2MassFitter.mass_zfit">mass_zfit</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.plot_mass_fit" href="#flarefly.fitter.F2MassFitter.plot_mass_fit">plot_mass_fit</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.plot_raw_residuals" href="#flarefly.fitter.F2MassFitter.plot_raw_residuals">plot_raw_residuals</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.plot_std_residuals" href="#flarefly.fitter.F2MassFitter.plot_std_residuals">plot_std_residuals</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_background_initpar" href="#flarefly.fitter.F2MassFitter.set_background_initpar">set_background_initpar</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_background_kde" href="#flarefly.fitter.F2MassFitter.set_background_kde">set_background_kde</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_background_template" href="#flarefly.fitter.F2MassFitter.set_background_template">set_background_template</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_particle_mass" href="#flarefly.fitter.F2MassFitter.set_particle_mass">set_particle_mass</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_reflection_kde" href="#flarefly.fitter.F2MassFitter.set_reflection_kde">set_reflection_kde</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_reflection_template" href="#flarefly.fitter.F2MassFitter.set_reflection_template">set_reflection_template</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_signal_initpar" href="#flarefly.fitter.F2MassFitter.set_signal_initpar">set_signal_initpar</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_signal_kde" href="#flarefly.fitter.F2MassFitter.set_signal_kde">set_signal_kde</a></code></li>
<li><code><a title="flarefly.fitter.F2MassFitter.set_signal_template" href="#flarefly.fitter.F2MassFitter.set_signal_template">set_signal_template</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>